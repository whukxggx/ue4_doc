[toc]

## 游戏模块

* 引擎本身由一组模块组成，每个游戏都由一个或多个模块组成。在ue4中，由于游戏都是由c++完成的，因此模块实际上是DLL，而不是专有的软件包文件。

* 游戏模块必须包括头文件，c++文件，和构建文件(*.Build.cs)
* 头文件必须位于模块目录的“公共”文件夹中，即[GameName] \ Source \ [ModuleName] \ Public。该文件包括编译模块中包含的类所需的所有头文件-包括模块的自动生成的头。
* C ++文件放置在模块目录的“专用”文件夹中，即[GameName] \ Source \ [ModuleName] \ Private，注册并实现该模块。
* 构建文件放置在游戏模块的根目录中，即[GameName] \ Source \ [ModuleName]，它定义了UnrealBuildTool用来编译模块的某些信息。
* [INI文件设置](https://docs.unrealengine.com/en-US/Programming/Modules/Gameplay/index.html)
* 您可以创建一个主要的游戏模块，然后创建任意数量的其他特定于游戏的模块。您可以为这些新模块创建* .Build.cs文件，然后将对这些模块的引用添加到游戏的[Target.cs文件](https://docs.unrealengine.com/en-US/Programming/BuildTools/UnrealBuildTool/TargetFiles/index.html) （OutExtraModuleNames数组）中。确保在C ++代码中为游戏模块使用适当的宏。至少一个模块必须使用IMPLEMENT_PRIMARY_GAME_MODULE宏，而其他模块都应使用IMPLEMENT_GAME_MODULE宏。然后，UBT应该自动发现模块并编译其他游戏DLL文件。

## **游戏类**

### 命名方案

* 字首为A，含义为从可生成的(spawnable)游戏对象的基类扩展。这些都是Actors，可以直接产生(be spawned)到世界上。
* 字首为U，含义为从所有游戏对象的基建类扩展，**这些不能被直接实例化为世界，他们必须属于一个Actor。这些通常是类似components的对象。

### 类的头文件

* 游戏类通常都有一个单独且唯一的类头文件，这些头文件通常的名字是类名减去前缀U或者A。

* 游戏类的类头文件将标准C ++语法与专用宏结合使用，以简化声明类，变量和函数的过程。

* 在每个游戏类标题文件的顶部，需要包括生成的标题文件（自动创建）。因此，在的顶部`ClassName.h`，必须出现以下行：

  ```c++
  #include "ClassName.generated.h"
  ```

### 类的声明

* 类声明定义了类的名称，它从哪个类继承以及由此继承到的任何函数和变量。

* 类声明还定义了通过[类说明符](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Classes/index.html#classspecifiers) 和元数据可能需要的其他特定于引擎和编辑器的行为。

* 语法如下:

  ```
  UCLASS([specifier, specifier, ...], [meta(key=value, key=value, ...)])
  class ClassName : public ParentName
  {
      GENERATED_BODY()
  }
  ```

  

* 在上述的标准声明中，描述符如类说明符和元数据被传递给UCLASS

  这些用于创建`UClass`要声明的类的，可以将其视为引擎对类的专门表示。同样，`GENERATED_BODY()` 宏必须放在类主体的最开始。

* 声明类的时候，类说明符可以添加到声明中来控制类的行为，在引擎和编辑器的各个方面。

* 部分类说明符

  | 说明符        | 作用                                                         |
  | ------------- | ------------------------------------------------------------ |
  | Blueprintable | 将此类公开为创建蓝图的可接受基类。默认值为`NotBlueprintable`，除非以其他方式继承。该说明符由子类继承。 |
  | BlueprintType | 将此类公开为可用于蓝图中变量的类型。                         |
  | EditInlineNew | 指示可以从“虚幻编辑器属性”窗口中创建此类的对象，而不是从现有资产中进行引用。默认行为是只能通过“属性”窗口分配对现有对象的引用。此说明符传播到所有子类。子类可以使用`NotEditInlineNew`Specifier 覆盖它。 |

* 在声明类，接口，结构，枚举，枚举值，函数或属性时，可以添加**元数据说明符**来控制它们在引擎和编辑器各个方面的行为。每种类型的数据结构或成员都有其自己的元数据说明符列表。[网页](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Classes/index.html)

### 类的实现

* **所有游戏类必须GENERATED_BODY才能正确实现。**
* **源文件必须包含C++类声明的头文件**

### 类构造

* `UObjects`使用**构造函数**设置属性和其他变量的默认值以及执行其他必要的初始化。通常将类构造函数放置在类实现文件中，例如，`AActor::AActor`构造函数位于中`Actor.cpp`。

* 也可以将构造函数内联放置在类头文件中。但是，如果构造函数在类头文件中，则必须用说明`CustomConstructor` 符声明UClass，因为这会阻止自动代码生成器在头文件中创建构造函数声明。

* UObject构造函数的最基本形式如下所示：

  ```c++
  UMyObject::UMyObject()
  {
      // Initialize Class Default Object properties here.
  }
  ```

  该构造函数初始化类默认对象（Class Default Object,CDO),他是该类将来的实例所属的主副本。还有一个辅助构造函数，它支持特殊的属性更改结构：

  ```c++
  UMyObject::UMyObject(const FObjectInitializer& ObjectInitializer)
  : Super(ObjectInitializer)
  {
      // Initialize CDO properties here.
  }
  ```

  尽管上述构造函数均未实际执行任何初始化，但是引擎已将所有字段初始化为零，NULL或它们的默认构造函数实现的任何值。但是，任何写入构造函数的初始化代码都将应用于CDO，因此将被复制到在引擎中正确创建的对象的任何新实例，如 `CreateNewObject`或`SpawnActor`。

* 构造函数的静态函数和辅助函数。

  为更复杂的数据类型（尤其是类引用，名称和资产引用）设置值时，需要在**构造**函数中定义并实例化一个**ConstructorStatics**结构，以容纳所需的各种属性值。`ConstructorStatics`仅在首次运行构造函数时创建此结构。在随后的运行中，它仅复制一个指针，这使其非常快。`ConstructorStatics`创建该结构时，将值分配给该结构的成员，以便稍后在构造函数中将值分配给实际属性本身时进行访问。

  **ContructorHelpers**是定义的特殊名称空间，`ObjectBase.h`其中包含用于执行特定于构造函数的常见操作的帮助程序模板。例如，有一些帮助程序模板，用于查找对资产或类的引用以及创建和查找组件。

  

### 类引用

`ConstructorHelpers::FClassFinder`查找对指定对象的引用，`UClass`如果找不到该类，则报告失败。

```
APylon::APylon(const class FObjectInitializer& ObjectInitializer)
: Super(ObjectInitializer)
{
    // Structure to hold one-time initialization
    static FClassFinder<UNavigationMeshBase> ClassFinder(TEXT("class'Engine.NavigationMeshBase'"));
    if (ClassFinder.Succeeded())
    {
        NavMeshClass = ClassFinder.Class;
    }
    else
    {
        NavMeshClass = nullptr;
    }
}
```

在许多情况下，您可以完全使用`USomeClass::StaticClass()`和跳过ClassFinder的复杂性。例如，在大多数情况下，您可以使用以下方法：

```c++
NavMeshClass = UNavigationMeshBase::StaticClass();
```

* 组件和子对象

  创建组件子对象并将其附加到参与者的层次结构也可以在构造函数内部完成。当生成一个actor时，其组件将从CDO中克隆。为了确保始终创建，销毁和正确收集组件，应将指向构造函数中创建的每个组件的指针存储在所属类的UPROPERTY中。

* UFUNCTION声明

  * **UFNCTION是受UE4反射系统识别的C++函数。**

  * 任何函数库或者蓝图函数库都可以通过将UFUNCTION宏放在头文件中函数声明上方的行上来将成员函数声明为UFUNCTION。

  * 该宏支持功能说明符，以更改UE4解释和使用功能的方式。

    ```c++
    UFUNCTION([specifier1=setting1, specifier2, ...], [meta(key1="value1", key2, ...)])
    ReturnType FunctionName([Parameter1, Parameter2, ..., ParameterN1=DefaultValueN1, ParameterN2=DefaultValueN2]) [const];
    ```

  * 使用功能说明符，您可以将UFunction公开给[Blueprint Visual Scripting](https://docs.unrealengine.com/en-US/Engine/Blueprints/index.html) 图形，这为开发人员提供了一种从Blueprint Assets调用或扩展UFunction的方法，而无需更改C ++代码。UFunction能够 在Class的默认属性中绑定到[Delegates](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates/index.html)，从而使它们能够执行诸如将动作与用户输入相关联的任务。它们还可以充当网络回调，这意味着只要某个变量受网络更新影响，您就可以使用它们来接收通知并运行自定义代码。

    [功能说明符和元数据说明符](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Functions/index.html)

  * 函数参数说明符

    | 参数说明符 | 描述                                                         |
    | :--------- | :----------------------------------------------------------- |
    | Out        | 将参数声明为通过引用传递，从而允许该函数对其进行修改。       |
    | Optional   | 使用optional关键字，可以将某些函数参数设置为可选，以方便调用者。调用者未指定的可选参数的值取决于函数。例如，该`SpawnActor`函数采用可选的位置和旋转方式，默认为产卵Actor根组件的位置和旋转方式。可选参数的默认值可以通过添加来指定`= [value]`。例如：`function myFunc(optional int x = -1)`。在大多数情况下，当没有值传递给可选参数时，将使用变量类型的默认值或零（0，false，“”，none）。 |

## 委托

**委托**可以以通用的类型安全的方式在C ++对象上调用成员函数。可以将委托动态绑定到任意对象的成员函数，即使将来调用者不知道对象的类型，也可以在将来对其进行调用。代表可以安全复制。您也可以按值传递它们，但是不建议这样做，因为此过程将在堆上分配内存；尽可能通过引用传递委托。引擎支持三种类型的委托：

### 单委托

### [多播委托](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates/Multicast/index.html),[Events](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates/Events/index.html)

### [动态](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates/Dynamic/index.html)

## 计时器

### [计时器](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Timers/index.html)

## 接口(interface)

### 接口声明

```c++
UINTERFACE([specifier, specifier, ...], [meta(key=value, key=value, ...)])
class UClassName : public UInterface
{
    GENERATED_BODY()
};
```

* UINTERFACE类不是实际的接口。它是一个空类，仅存在于虚幻引擎的反射系统可见性中。将由其他类继承的实际接口必须具有相同的类名，但是初始的“ U”更改为“ I”。

* 例子

  ```c++
  //ReactToTriggerInterface.h
  #pragma once
  
  #include "ReactToTriggerInterface.generated.h"
  
  UINTERFACE(MinimalAPI, Blueprintable)
  class UReactToTriggerInterface : public UInterface
  {
      GENERATED_BODY()
  };
  
  class IReactToTriggerInterface
  {    
      GENERATED_BODY()
  
  public:
      /** Add interface function declarations here */
  };
  ```

“U前缀”类不需要构造函数或任何其他函数，而“ I前缀”类将包含所有接口函数，并且实际上将由您的其他类继承。

`Blueprintable`如果要允许蓝图实现此接口，则需要该说明符。

### 各种数据说明符

* [接口说明符](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Interfaces/index.html)

* 要在新类中使用您的接口，**只需从“ I前缀”接口类继承**（除了`UObject`您正在使用的任何基于类的类）。

* **元数据说明符**

  [详细说明和用例](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/index.html)

  * 添加元数据说明符，用这个词`meta`，随后符的列表，并且，如果合适的话，他们的价值，你`UCLASS`，`UENUM`，`UINTERFACE`，`USTRUCT`，`UFUNCTION`，或`UPROPERTY`宏，如下所示：

    ```
    {UCLASS/UENUM/UINTERFACE/USTRUCT/UFUNCTION/UPROPERTY}(SpecifierX, meta=(MetaTag1="Value1", MetaTag2, ..), SpecifierY)
    ```

  [类元数据说明符](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/index.html)

  [枚举元数据说明符](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/index.html)

  [接口元数据说明符](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/index.html)

  [结构元数据说明符](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/index.html)

  [函数元数据说明符](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/index.html)

  

## 属性

  

### 属性声明

```c++
UPROPERTY([specifier, specifier, ...], [meta(key=value, key=value, ...)])
Type VariableName;
```

### 核心数据类型

* 整形

  整数数据类型的约定为“ int”或“ uint”，后跟以位为单位的大小。

  | 变量类型   | 描述       |
  | :--------- | :--------- |
  | **uint8**  | 8位无符号  |
  | **uint16** | 16位无符号 |
  | **uint32** | 32位无符号 |
  | **uint64** | 64位无符号 |
  | **int8**   | 8位带符号  |
  | **int16**  | 16位带符号 |
  | **int32**  | 32位带符号 |
  | **int64**  | 64位带符号 |



* 浮点类型

  ue4使用标准的C ++浮点类型，float和double。

* 布尔类型可以用C ++ bool关键字或位域表示。

* Strings

  ue4支持三种类型的字符串

  * FString是经典的“动态字符数组”字符串类型。

  * FName是对全局字符串表中不可变的不区分大小写的字符串的引用。它比FString较小，传递效率更高，但更难操纵。

  * FText是设计用于处理本地化的更健壮的字符串表示形式。

  * 对于大多数用途，ue4依赖于字符的TCHAR类型。TEXT()宏可用于表示TCHAR文字。

    ```c++
    MyDogPtr->DogName = FName(TEXT("Samson Aloysius"));
    ```

  * 字符串处理

    [字符串处理](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/StringHandling/index.html)

### 属性说明符

  声明属性时，可以将**属性说明符**添加到声明中，以控制属性在引擎和编辑器各个方面的行为。

## 结构

ue4中的**结构**可由引擎的反射系统识别，但不属于`UObject`生态系统。结果，`UObject`与具有相同数据布局的相比，它们的创建速度更快，并且支持UProperty，但不会由垃圾回收系统管理，也无法提供UFunction。要将结构变成UStruct，请使用`USTRUCT`结构定义上方的标记，并将其`GENERATED_BODY()`作为定义中的第一行，如下所示：

```
USTRUCT([Specifier, Specifier, ...])
struct StructName
{
    GENERATED_BODY()
};
```

## 数据验证

该编辑器具有一个**数据验证**插件，供开发人员使用自定义脚本规则集验证资产。、

常见的验证用例:

- 检查以确保资产符合名称约定
- 执行空间和性能预算
- 捕捉非循环依赖

* 插件
  * 在UE4中，插件是开发人员可以在每个项目的基础上轻松启用或禁用的代码和数据的集合。
  * 插件可以添加运行时游戏功能，修改内置的Engine功能（或添加新功能），创建新的文件类型，并使用新的菜单，工具栏命令和子模式扩展编辑器的功能。许多现有的UE4子系统被设计为可使用插件进行扩展。
  * [具体开发和管理](https://docs.unrealengine.com/en-US/Programming/Plugins/index.html)

## 部署引擎

  [部署引擎](https://docs.unrealengine.com/en-US/Programming/Deployment/index.html)

## 在线子系统

### 目的

**从根本上设计是为了处理与各种在线服务的异步通信。**

由于本地计算机不知道网络连接速度，服务器延迟和后端服务的运行时间，因此与这些系统的交互花费了不可预测的时间。为了解决这个问题，在线子系统将[委托](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates/index.html) 用于所有远程操作，并保证只要使用了受支持的异步功能，这些委托就会被调用。除了提供在请求完成时响应请求以及查询运行中请求的功能。代表们还提供了一条遵循的单一代码路径，从而无需开发人员编写自定义代码来捕获不同的成功或失败条件。

### 提供的接口

| 接口                                                         | 功能组描述                                                   |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [成就](https://docs.unrealengine.com/en-US/Programming/Online/AchievementsInterface/index.html) | 列出游戏中的所有成就，解锁成就，并检查您自己的解锁成就和其他用户的成就。 |
| [外部用户界面](https://docs.unrealengine.com/en-US/Programming/Online/ExternalUIInterface/index.html) | 打开特定硬件平台或在线服务的内置用户界面。在某些情况下，服务仅通过此接口授予对某些核心功能的访问权限。 |
| [朋友界面](https://docs.unrealengine.com/en-US/Programming/Online/FriendsInterface/index.html) | 与朋友和朋友列表相关的所有内容，例如将用户添加到您的朋友列表，阻止和取消阻止用户以及列出您最近在网上遇到的玩家。 |
| [排行榜](https://docs.unrealengine.com/en-US/Programming/Online/LeaderboardInterface/index.html) | 访问在线排行榜，包括注册自己的分数（或时间），以及检查排行榜中来自您的朋友列表或世界各地玩家的分数。 |
| [在线用户](https://docs.unrealengine.com/en-US/Programming/Online/OnlineUserInterface/index.html) | 收集有关用户的元数据。                                       |
| [存在](https://docs.unrealengine.com/en-US/Programming/Online/PresenceInterface/index.html) | 设置用户在线状态对其他用户的显示方式，例如“在线”，“离开”，“玩游戏”等。 |
| [采购](https://docs.unrealengine.com/en-US/Programming/Online/PurchaseInterface/index.html) | 进行游戏内购买并查看过去的购买历史。                         |
| [会话](https://docs.unrealengine.com/en-US/Programming/Online/SessionInterface/index.html) | 创建，销毁和管理在线游戏会话。还包括搜索会议和配对系统。     |
| [商店](https://docs.unrealengine.com/en-US/Programming/Online/StoreInterface/index.html) | 检索可用于游戏内购买的类别和特定优惠。                       |
| 用户云                                                       | 提供用于每个用户云文件存储的界面。                           |

## unreal架构

### UObjects和Actor

[Actor](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Actors/index.html) 是派生自[ AActor](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AActor) 类的类的实例；可以放置到世界上的所有游戏对象的基类。[对象](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Objects/index.html) 是从[ UObject](https://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/UObject/UObject) 类继承的类的实例。虚幻引擎中所有对象（包括Actor）的基类。因此，实际上，虚幻引擎中的所有实例都是对象。但是，术语 **Actors**通常用于指代 从其层次结构中的[ AActor](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AActor)派生的类的实例，而术语Objects用于表示不从[ AActor](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AActor) 类继承的类的实例。您创建的大多数类都将从[ AActor](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AActor)继承 在他们的层次结构中的某个时候。

通常，可以将Actor视为整个项目或实体，而Object是更专门的部分。参与者通常利用作为 特殊对象的[Components](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Actors/Components/index.html)来定义其功能的某些方面，或保留属性集合的值。以汽车为例。整个汽车是一个Actor，而汽车的各个部分（如车轮和门）都是该Actor的组件。

### 游戏框架类

基本的游戏类包括代表玩家，盟友和敌人的功能，以及通过玩家输入或AI逻辑控制这些化身的功能。还有一些用于为玩家创建平视显示器和摄像机的类。最后，诸如**GameMode**，**GameState**和**PlayerState之**类的游戏类设置游戏规则，并跟踪游戏和玩家的进度。

这些类都创建Actor类型，可以将其放置在关卡中或在需要时生成。

| 类型                     | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| pawn(被利用的人，兵，卒) | 一个pawn可以是一个Actor，作为一个代理在世界中。pawn可以由控制者拥有，可以将它们设置为易于接受输入，并且可以执行各种其他与玩家类似的事情。注意，pawn并不被认为是类人的。 |
| character                | 人形分割的pawn。默认情况下，它带有一个用于碰撞的CapsuleComponent和一个CharacterMovementComponent。它可以进行类似人类的基本动作，可以在网络上平滑地复制动作，并且具有一些与动画相关的功能。 |

### 使用玩家输入或者AI逻辑控制棋子

|                      |                                                              |
| -------------------- | ------------------------------------------------------------ |
| **controller**       | [Controller](https://docs.unrealengine.com/en-US/Gameplay/Framework/Controller/index.html) 是负责指挥Pawn的Actor。它们通常有两种风格，即AIController和PlayerController。控制器可以“拥有”一个Pawn来控制它。 |
| **PlayerController** | 一[的PlayerController](https://docs.unrealengine.com/en-US/Gameplay/Framework/Controller/PlayerController/index.html) 是pawn和人类玩家控制它之间的接口。PlayerController本质上代表着人类玩家的意志。 |
| **AIController**     | 听起来像是一个AIController。可以控制Pawn的模拟“意愿”。       |

### 向玩家显示信息

| HUD        | 一个[HUD](https://docs.unrealengine.com/en-US/Gameplay/Framework/UIAndHUD/index.html) 是“抬头显示器”，或在2D屏幕上显示的是常见于许多游戏。考虑一下健康状况，弹药，枪口等。每个PlayerController通常都有其中之一。 |
| ---------- | ------------------------------------------------------------ |
| **Camera** | PlayerCameraManager是玩家的“眼球”，并管理其行为。每个PlayerController通常也具有其中之一。有关更多信息，请参见[相机工作流程](https://docs.unrealengine.com/en-US/Gameplay/Framework/Camera/index.html) 页面。 |

### 设定和追踪游戏规则

| GameMode    | “游戏”的概念分为2类。在[游戏模式和游戏状态](https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/index.html) 是游戏的定义，包括像游戏规则的事情，赢得条件。它仅存在于服务器上。它通常不应包含在播放过程中发生更改的大量数据，并且绝对不应包含客户端需要了解的瞬时数据。 |
| ----------- | ------------------------------------------------------------ |
| GameState   | 该[游戏状态](https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/index.html#gamestate) 包括游戏，这可能包括像连接的玩家，得分，棋局中棋子的位置，或者你在一个开放的世界游戏完成的任务列表。GameState存在于服务器和所有客户端上，可以自由复制以使所有计算机保持最新状态。 |
| PlayerState | 一个**PlayerState**是在游戏中，参与者的状态，诸如人类玩家或者是模拟人类的机器人。作为游戏一部分存在的Non-Player AI将没有PlayerState。在PlayerState中合适的示例数据包括玩家名称，得分，MOBA之类的比赛水平，或者玩家当前是否在CTF游戏中携带旗帜。所有玩家的PlayerStates存在于所有机器上（不同于PlayerControllers），并且可以自由复制以保持事物同步。 |