[toc]

## 游戏模块

* 引擎本身由一组模块组成，每个游戏都由一个或多个模块组成。在ue4中，由于游戏都是由c++完成的，因此模块实际上是DLL，而不是专有的软件包文件。

* 游戏模块必须包括头文件，c++文件，和构建文件(*.Build.cs)
* 头文件必须位于模块目录的“公共”文件夹中，即[GameName] \ Source \ [ModuleName] \ Public。该文件包括编译模块中包含的类所需的所有头文件-包括模块的自动生成的头。
* C ++文件放置在模块目录的“专用”文件夹中，即[GameName] \ Source \ [ModuleName] \ Private，注册并实现该模块。
* 构建文件放置在游戏模块的根目录中，即[GameName] \ Source \ [ModuleName]，它定义了UnrealBuildTool用来编译模块的某些信息。
* [INI文件设置](https://docs.unrealengine.com/en-US/Programming/Modules/Gameplay/index.html)
* 您可以创建一个主要的游戏模块，然后创建任意数量的其他特定于游戏的模块。您可以为这些新模块创建* .Build.cs文件，然后将对这些模块的引用添加到游戏的[Target.cs文件](https://docs.unrealengine.com/en-US/Programming/BuildTools/UnrealBuildTool/TargetFiles/index.html) （OutExtraModuleNames数组）中。确保在C ++代码中为游戏模块使用适当的宏。至少一个模块必须使用IMPLEMENT_PRIMARY_GAME_MODULE宏，而其他模块都应使用IMPLEMENT_GAME_MODULE宏。然后，UBT应该自动发现模块并编译其他游戏DLL文件。

## **游戏类**

### 命名方案

* 字首为A，含义为从可生成的(spawnable)游戏对象的基类扩展。这些都是Actors，可以直接产生(be spawned)到世界上。
* 字首为U，含义为从所有游戏对象的基建类扩展，**这些不能被直接实例化为世界，他们必须属于一个Actor。这些通常是类似components的对象。

### 类的头文件

* 游戏类通常都有一个单独且唯一的类头文件，这些头文件通常的名字是类名减去前缀U或者A。

* 游戏类的类头文件将标准C ++语法与专用宏结合使用，以简化声明类，变量和函数的过程。

* 在每个游戏类标题文件的顶部，需要包括生成的标题文件（自动创建）。因此，在的顶部`ClassName.h`，必须出现以下行：

  ```c++
  #include "ClassName.generated.h"
  ```

### 类的声明

* 类声明定义了类的名称，它从哪个类继承以及由此继承到的任何函数和变量。

* 类声明还定义了通过[类说明符](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Classes/index.html#classspecifiers) 和元数据可能需要的其他特定于引擎和编辑器的行为。

* 语法如下:

  ```
  UCLASS([specifier, specifier, ...], [meta(key=value, key=value, ...)])
  class ClassName : public ParentName
  {
      GENERATED_BODY()
  }
  ```

  

* 在上述的标准声明中，描述符如类说明符和元数据被传递给UCLASS

  这些用于创建`UClass`要声明的类的，可以将其视为引擎对类的专门表示。同样，`GENERATED_BODY()` 宏必须放在类主体的最开始。

* 声明类的时候，类说明符可以添加到声明中来控制类的行为，在引擎和编辑器的各个方面。

* 部分类说明符

  | 说明符        | 作用                                                         |
  | ------------- | ------------------------------------------------------------ |
  | Blueprintable | 将此类公开为创建蓝图的可接受基类。默认值为`NotBlueprintable`，除非以其他方式继承。该说明符由子类继承。 |
  | BlueprintType | 将此类公开为可用于蓝图中变量的类型。                         |
  | EditInlineNew | 指示可以从“虚幻编辑器属性”窗口中创建此类的对象，而不是从现有资产中进行引用。默认行为是只能通过“属性”窗口分配对现有对象的引用。此说明符传播到所有子类。子类可以使用`NotEditInlineNew`Specifier 覆盖它。 |

* 在声明类，接口，结构，枚举，枚举值，函数或属性时，可以添加**元数据说明符**来控制它们在引擎和编辑器各个方面的行为。每种类型的数据结构或成员都有其自己的元数据说明符列表。[网页](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Classes/index.html)

### 类的实现

* **所有游戏类必须GENERATED_BODY才能正确实现。**
* **源文件必须包含C++类声明的头文件**

### 类构造

* `UObjects`使用**构造函数**设置属性和其他变量的默认值以及执行其他必要的初始化。通常将类构造函数放置在类实现文件中，例如，`AActor::AActor`构造函数位于中`Actor.cpp`。

* 也可以将构造函数内联放置在类头文件中。但是，如果构造函数在类头文件中，则必须用说明`CustomConstructor` 符声明UClass，因为这会阻止自动代码生成器在头文件中创建构造函数声明。

* UObject构造函数的最基本形式如下所示：

  ```c++
  UMyObject::UMyObject()
  {
      // Initialize Class Default Object properties here.
  }
  ```

  该构造函数初始化类默认对象（Class Default Object,CDO),他是该类将来的实例所属的主副本。还有一个辅助构造函数，它支持特殊的属性更改结构：

  ```c++
  UMyObject::UMyObject(const FObjectInitializer& ObjectInitializer)
  : Super(ObjectInitializer)
  {
      // Initialize CDO properties here.
  }
  ```

  尽管上述构造函数均未实际执行任何初始化，但是引擎已将所有字段初始化为零，NULL或它们的默认构造函数实现的任何值。但是，任何写入构造函数的初始化代码都将应用于CDO，因此将被复制到在引擎中正确创建的对象的任何新实例，如 `CreateNewObject`或`SpawnActor`。

* 构造函数的静态函数和辅助函数。

  为更复杂的数据类型（尤其是类引用，名称和资产引用）设置值时，需要在**构造**函数中定义并实例化一个**ConstructorStatics**结构，以容纳所需的各种属性值。`ConstructorStatics`仅在首次运行构造函数时创建此结构。在随后的运行中，它仅复制一个指针，这使其非常快。`ConstructorStatics`创建该结构时，将值分配给该结构的成员，以便稍后在构造函数中将值分配给实际属性本身时进行访问。

  **ContructorHelpers**是定义的特殊名称空间，`ObjectBase.h`其中包含用于执行特定于构造函数的常见操作的帮助程序模板。例如，有一些帮助程序模板，用于查找对资产或类的引用以及创建和查找组件。

  

### 类引用

`ConstructorHelpers::FClassFinder`查找对指定对象的引用，`UClass`如果找不到该类，则报告失败。

```
APylon::APylon(const class FObjectInitializer& ObjectInitializer)
: Super(ObjectInitializer)
{
    // Structure to hold one-time initialization
    static FClassFinder<UNavigationMeshBase> ClassFinder(TEXT("class'Engine.NavigationMeshBase'"));
    if (ClassFinder.Succeeded())
    {
        NavMeshClass = ClassFinder.Class;
    }
    else
    {
        NavMeshClass = nullptr;
    }
}
```

在许多情况下，您可以完全使用`USomeClass::StaticClass()`和跳过ClassFinder的复杂性。例如，在大多数情况下，您可以使用以下方法：

```c++
NavMeshClass = UNavigationMeshBase::StaticClass();
```

* 组件和子对象

  创建组件子对象并将其附加到参与者的层次结构也可以在构造函数内部完成。当生成一个actor时，其组件将从CDO中克隆。为了确保始终创建，销毁和正确收集组件，应将指向构造函数中创建的每个组件的指针存储在所属类的UPROPERTY中。

* UFUNCTION声明

  * **UFNCTION是受UE4反射系统识别的C++函数。**

  * 任何函数库或者蓝图函数库都可以通过将UFUNCTION宏放在头文件中函数声明上方的行上来将成员函数声明为UFUNCTION。

  * 该宏支持功能说明符，以更改UE4解释和使用功能的方式。

    ```c++
    UFUNCTION([specifier1=setting1, specifier2, ...], [meta(key1="value1", key2, ...)])
    ReturnType FunctionName([Parameter1, Parameter2, ..., ParameterN1=DefaultValueN1, ParameterN2=DefaultValueN2]) [const];
    ```

  * 使用功能说明符，您可以将UFunction公开给[Blueprint Visual Scripting](https://docs.unrealengine.com/en-US/Engine/Blueprints/index.html) 图形，这为开发人员提供了一种从Blueprint Assets调用或扩展UFunction的方法，而无需更改C ++代码。UFunction能够 在Class的默认属性中绑定到[Delegates](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates/index.html)，从而使它们能够执行诸如将动作与用户输入相关联的任务。它们还可以充当网络回调，这意味着只要某个变量受网络更新影响，您就可以使用它们来接收通知并运行自定义代码。

    [功能说明符和元数据说明符](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Functions/index.html)

  * 函数参数说明符

    | 参数说明符 | 描述                                                         |
    | :--------- | :----------------------------------------------------------- |
    | Out        | 将参数声明为通过引用传递，从而允许该函数对其进行修改。       |
    | Optional   | 使用optional关键字，可以将某些函数参数设置为可选，以方便调用者。调用者未指定的可选参数的值取决于函数。例如，该`SpawnActor`函数采用可选的位置和旋转方式，默认为产卵Actor根组件的位置和旋转方式。可选参数的默认值可以通过添加来指定`= [value]`。例如：`function myFunc(optional int x = -1)`。在大多数情况下，当没有值传递给可选参数时，将使用变量类型的默认值或零（0，false，“”，none）。 |

## 委托

**委托**可以以通用的类型安全的方式在C ++对象上调用成员函数。可以将委托动态绑定到任意对象的成员函数，即使将来调用者不知道对象的类型，也可以在将来对其进行调用。代表可以安全复制。您也可以按值传递它们，但是不建议这样做，因为此过程将在堆上分配内存；尽可能通过引用传递委托。引擎支持三种类型的委托：

### 单委托

### [多播委托](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates/Multicast/index.html),[Events](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates/Events/index.html)

### [动态](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates/Dynamic/index.html)

## 计时器

### [计时器](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Timers/index.html)

## 接口(interface)

### 接口声明

```c++
UINTERFACE([specifier, specifier, ...], [meta(key=value, key=value, ...)])
class UClassName : public UInterface
{
    GENERATED_BODY()
};
```

* UINTERFACE类不是实际的接口。它是一个空类，仅存在于虚幻引擎的反射系统可见性中。将由其他类继承的实际接口必须具有相同的类名，但是初始的“ U”更改为“ I”。

* 例子

  ```c++
  //ReactToTriggerInterface.h
  #pragma once
  
  #include "ReactToTriggerInterface.generated.h"
  
  UINTERFACE(MinimalAPI, Blueprintable)
  class UReactToTriggerInterface : public UInterface
  {
      GENERATED_BODY()
  };
  
  class IReactToTriggerInterface
  {    
      GENERATED_BODY()
  
  public:
      /** Add interface function declarations here */
  };
  ```

“U前缀”类不需要构造函数或任何其他函数，而“ I前缀”类将包含所有接口函数，并且实际上将由您的其他类继承。

`Blueprintable`如果要允许蓝图实现此接口，则需要该说明符。

### 各种数据说明符

* [接口说明符](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Interfaces/index.html)

* 要在新类中使用您的接口，**只需从“ I前缀”接口类继承**（除了`UObject`您正在使用的任何基于类的类）。

* **元数据说明符**

  [详细说明和用例](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/index.html)

  * 添加元数据说明符，用这个词`meta`，随后符的列表，并且，如果合适的话，他们的价值，你`UCLASS`，`UENUM`，`UINTERFACE`，`USTRUCT`，`UFUNCTION`，或`UPROPERTY`宏，如下所示：

    ```
    {UCLASS/UENUM/UINTERFACE/USTRUCT/UFUNCTION/UPROPERTY}(SpecifierX, meta=(MetaTag1="Value1", MetaTag2, ..), SpecifierY)
    ```

  [类元数据说明符](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/index.html)

  [枚举元数据说明符](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/index.html)

  [接口元数据说明符](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/index.html)

  [结构元数据说明符](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/index.html)

  [函数元数据说明符](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/index.html)

  

## 属性

  

### 属性声明

```c++
UPROPERTY([specifier, specifier, ...], [meta(key=value, key=value, ...)])
Type VariableName;
```

### 核心数据类型

* 整形

  整数数据类型的约定为“ int”或“ uint”，后跟以位为单位的大小。

  | 变量类型   | 描述       |
  | :--------- | :--------- |
  | **uint8**  | 8位无符号  |
  | **uint16** | 16位无符号 |
  | **uint32** | 32位无符号 |
  | **uint64** | 64位无符号 |
  | **int8**   | 8位带符号  |
  | **int16**  | 16位带符号 |
  | **int32**  | 32位带符号 |
  | **int64**  | 64位带符号 |



* 浮点类型

  ue4使用标准的C ++浮点类型，float和double。

* 布尔类型可以用C ++ bool关键字或位域表示。

* Strings

  ue4支持三种类型的字符串

  * FString是经典的“动态字符数组”字符串类型。

  * FName是对全局字符串表中不可变的不区分大小写的字符串的引用。它比FString较小，传递效率更高，但更难操纵。

  * FText是设计用于处理本地化的更健壮的字符串表示形式。

  * 对于大多数用途，ue4依赖于字符的TCHAR类型。TEXT()宏可用于表示TCHAR文字。

    ```c++
    MyDogPtr->DogName = FName(TEXT("Samson Aloysius"));
    ```

  * 字符串处理

    [字符串处理](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/StringHandling/index.html)

### 属性说明符

  声明属性时，可以将**属性说明符**添加到声明中，以控制属性在引擎和编辑器各个方面的行为。

## 结构

ue4中的**结构**可由引擎的反射系统识别，但不属于`UObject`生态系统。结果，`UObject`与具有相同数据布局的相比，它们的创建速度更快，并且支持UProperty，但不会由垃圾回收系统管理，也无法提供UFunction。要将结构变成UStruct，请使用`USTRUCT`结构定义上方的标记，并将其`GENERATED_BODY()`作为定义中的第一行，如下所示：

```
USTRUCT([Specifier, Specifier, ...])
struct StructName
{
    GENERATED_BODY()
};
```

## 数据验证

该编辑器具有一个**数据验证**插件，供开发人员使用自定义脚本规则集验证资产。、

常见的验证用例:

- 检查以确保资产符合名称约定
- 执行空间和性能预算
- 捕捉非循环依赖

* 插件
  * 在UE4中，插件是开发人员可以在每个项目的基础上轻松启用或禁用的代码和数据的集合。
  * 插件可以添加运行时游戏功能，修改内置的Engine功能（或添加新功能），创建新的文件类型，并使用新的菜单，工具栏命令和子模式扩展编辑器的功能。许多现有的UE4子系统被设计为可使用插件进行扩展。
  * [具体开发和管理](https://docs.unrealengine.com/en-US/Programming/Plugins/index.html)

## 部署引擎

  [部署引擎](https://docs.unrealengine.com/en-US/Programming/Deployment/index.html)

## 在线子系统

### 目的

**从根本上设计是为了处理与各种在线服务的异步通信。**

由于本地计算机不知道网络连接速度，服务器延迟和后端服务的运行时间，因此与这些系统的交互花费了不可预测的时间。为了解决这个问题，在线子系统将[委托](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates/index.html) 用于所有远程操作，并保证只要使用了受支持的异步功能，这些委托就会被调用。除了提供在请求完成时响应请求以及查询运行中请求的功能。代表们还提供了一条遵循的单一代码路径，从而无需开发人员编写自定义代码来捕获不同的成功或失败条件。

### 提供的接口

| 接口                                                         | 功能组描述                                                   |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [成就](https://docs.unrealengine.com/en-US/Programming/Online/AchievementsInterface/index.html) | 列出游戏中的所有成就，解锁成就，并检查您自己的解锁成就和其他用户的成就。 |
| [外部用户界面](https://docs.unrealengine.com/en-US/Programming/Online/ExternalUIInterface/index.html) | 打开特定硬件平台或在线服务的内置用户界面。在某些情况下，服务仅通过此接口授予对某些核心功能的访问权限。 |
| [朋友界面](https://docs.unrealengine.com/en-US/Programming/Online/FriendsInterface/index.html) | 与朋友和朋友列表相关的所有内容，例如将用户添加到您的朋友列表，阻止和取消阻止用户以及列出您最近在网上遇到的玩家。 |
| [排行榜](https://docs.unrealengine.com/en-US/Programming/Online/LeaderboardInterface/index.html) | 访问在线排行榜，包括注册自己的分数（或时间），以及检查排行榜中来自您的朋友列表或世界各地玩家的分数。 |
| [在线用户](https://docs.unrealengine.com/en-US/Programming/Online/OnlineUserInterface/index.html) | 收集有关用户的元数据。                                       |
| [存在](https://docs.unrealengine.com/en-US/Programming/Online/PresenceInterface/index.html) | 设置用户在线状态对其他用户的显示方式，例如“在线”，“离开”，“玩游戏”等。 |
| [采购](https://docs.unrealengine.com/en-US/Programming/Online/PurchaseInterface/index.html) | 进行游戏内购买并查看过去的购买历史。                         |
| [会话](https://docs.unrealengine.com/en-US/Programming/Online/SessionInterface/index.html) | 创建，销毁和管理在线游戏会话。还包括搜索会议和配对系统。     |
| [商店](https://docs.unrealengine.com/en-US/Programming/Online/StoreInterface/index.html) | 检索可用于游戏内购买的类别和特定优惠。                       |
| 用户云                                                       | 提供用于每个用户云文件存储的界面。                           |

## unreal架构

### UObjects和Actor

[Actor](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Actors/index.html) 是派生自[ AActor](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AActor) 类的类的实例；可以放置到世界上的所有游戏对象的基类。[对象](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Objects/index.html) 是从[ UObject](https://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/UObject/UObject) 类继承的类的实例。虚幻引擎中所有对象（包括Actor）的基类。因此，实际上，虚幻引擎中的所有实例都是对象。但是，术语 **Actors**通常用于指代 从其层次结构中的[ AActor](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AActor)派生的类的实例，而术语Objects用于表示不从[ AActor](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AActor) 类继承的类的实例。您创建的大多数类都将从[ AActor](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AActor)继承 在他们的层次结构中的某个时候。

通常，可以将Actor视为整个项目或实体，而Object是更专门的部分。参与者通常利用作为 特殊对象的[Components](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Actors/Components/index.html)来定义其功能的某些方面，或保留属性集合的值。以汽车为例。整个汽车是一个Actor，而汽车的各个部分（如车轮和门）都是该Actor的组件。

### 游戏框架类

基本的游戏类包括代表玩家，盟友和敌人的功能，以及通过玩家输入或AI逻辑控制这些化身的功能。还有一些用于为玩家创建平视显示器和摄像机的类。最后，诸如**GameMode**，**GameState**和**PlayerState之**类的游戏类设置游戏规则，并跟踪游戏和玩家的进度。

这些类都创建Actor类型，可以将其放置在关卡中或在需要时生成。

| 类型                     | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| pawn(被利用的人，兵，卒) | 一个pawn可以是一个Actor，作为一个代理在世界中。pawn可以由控制者拥有，可以将它们设置为易于接受输入，并且可以执行各种其他与玩家类似的事情。注意，pawn并不被认为是类人的。 |
| character                | 人形分割的pawn。默认情况下，它带有一个用于碰撞的CapsuleComponent和一个CharacterMovementComponent。它可以进行类似人类的基本动作，可以在网络上平滑地复制动作，并且具有一些与动画相关的功能。 |

### 使用玩家输入或者AI逻辑控制棋子

|                      |                                                              |
| -------------------- | ------------------------------------------------------------ |
| **controller**       | [Controller](https://docs.unrealengine.com/en-US/Gameplay/Framework/Controller/index.html) 是负责指挥Pawn的Actor。它们通常有两种风格，即AIController和PlayerController。控制器可以“拥有”一个Pawn来控制它。 |
| **PlayerController** | 一[的PlayerController](https://docs.unrealengine.com/en-US/Gameplay/Framework/Controller/PlayerController/index.html) 是pawn和人类玩家控制它之间的接口。PlayerController本质上代表着人类玩家的意志。 |
| **AIController**     | 听起来像是一个AIController。可以控制Pawn的模拟“意愿”。       |

### 向玩家显示信息

| HUD        | 一个[HUD](https://docs.unrealengine.com/en-US/Gameplay/Framework/UIAndHUD/index.html) 是“抬头显示器”，或在2D屏幕上显示的是常见于许多游戏。考虑一下健康状况，弹药，枪口等。每个PlayerController通常都有其中之一。 |
| ---------- | ------------------------------------------------------------ |
| **Camera** | PlayerCameraManager是玩家的“眼球”，并管理其行为。每个PlayerController通常也具有其中之一。有关更多信息，请参见[相机工作流程](https://docs.unrealengine.com/en-US/Gameplay/Framework/Camera/index.html) 页面。 |

### 设定和追踪游戏规则

| GameMode    | “游戏”的概念分为2类。在[游戏模式和游戏状态](https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/index.html) 是游戏的定义，包括像游戏规则的事情，赢得条件。它仅存在于服务器上。它通常不应包含在播放过程中发生更改的大量数据，并且绝对不应包含客户端需要了解的瞬时数据。 |
| ----------- | ------------------------------------------------------------ |
| GameState   | 该[游戏状态](https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/index.html#gamestate) 包括游戏，这可能包括像连接的玩家，得分，棋局中棋子的位置，或者你在一个开放的世界游戏完成的任务列表。GameState存在于服务器和所有客户端上，可以自由复制以使所有计算机保持最新状态。 |
| PlayerState | 一个**PlayerState**是在游戏中，参与者的状态，诸如人类玩家或者是模拟人类的机器人。作为游戏一部分存在的Non-Player AI将没有PlayerState。在PlayerState中合适的示例数据包括玩家名称，得分，MOBA之类的比赛水平，或者玩家当前是否在CTF游戏中携带旗帜。所有玩家的PlayerStates存在于所有机器上（不同于PlayerControllers），并且可以自由复制以保持事物同步。 |

### 框架类关系

此流程图说明了这些核心游戏类如何相互关联。游戏由GameMode和GameState组成。加入游戏的人类玩家与PlayerControllers相关联。这些PlayerController允许玩家在游戏中拥有棋子，因此他们可以在关卡中具有物理表示。PlayerControllers还为玩家提供输入控件，平视显示器或HUD，以及用于处理摄像机视图的PlayerCameraManager。

![流程图](https://github.com/whukxggx/ue4_doc/blob/master/%E6%A1%86%E6%9E%B6%E7%B1%BB%E5%85%B3%E7%B3%BB.png?raw=true)

## Actors

一个Actor可以是被放置到一个水平的任何对象。Actor是支持3D转换(平移，旋转，缩放)的通用类。Actors可以通过游戏代码（c++或者蓝图）被创造(created,spawned)或者摧毁。In C++, AActor is the base class of all Actors.

有几种不同的Actors，一些例子包括：StaticMeshActor,CameraActor,PlayerStartActor.

**注意actors不存储转换数据。如果存在，则使用Actor的根组件的转换数据。**

### 创建Actors

创建新的AActor的实例称为spawning。

[详细生成方法](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Actors/Spawning/index.html)

### 组件(component)

[详细地址](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Actors/Components/index.html)

**Actos在某种意义上可以认为是作为各种特殊对象(组件)的容器.不同类型的组件可以被用来控制Actors怎么移动，怎么渲染等。**

**actor的另一个作用是在玩的时候通过网络复制属性和函数调用。**

组件是在创建的时候与actor相关联。

一些关键组件类型：

#### **UActorComponent**

这个是*基本组件*。这个可以作为Actor的一部分。如果你愿意，可以tick(打勾，做标记？)。UActorComponent通常与一个特定的Actor联系，但是不存在于世界上的任何特定地方。它们通常用于概念上的功能，比如Ai或者解释玩家输入。

**`UActorComponent`是所有组件的基类。**

由于组件是渲染网格和图像，实现碰撞以及播放音频的唯一方法，**因此玩家在玩游戏时在世界上看到或与之交互的一切最终都是某种类型的组件的工作。**

#### **USceneComponent**

这个是具有转换的ActorComponents。**一个转换是世界上的一个位置，由位置，旋转和缩放定义**。SceneComponents可以以分层方式彼此附加。Actor的位置，旋转和比例**取自位于层次结构根部的SceneComponent**

**Scene Components** (class `USceneComponent`, a child of `UActorComponent`) 支持不需要几何表示的基于位置的行为。这包括弹簧臂，摄像机，物理力和约束（但不包括物理对象），甚至包括音频。

场景组件是存在于世界上特定物理位置的演员组件。该位置由一个**转换**（class [`FTransform`](https://api.unrealengine.com/INT/API/Runtime/Core/Math/FTransform/index.htm) ）定义，其中包含Component的位置，旋转和比例。场景组件具有通过彼此附着而形成树的能力，并且Actor可以将单个场景组件指定为“根”，这意味着Actor的世界位置，旋转和比例是从该组件绘制的。

`USceneComponent`由于需要转换以描述子组件和父组件之间的空间关系，因此只有场景组件（及其子类）可以彼此附加。尽管场景组件可以有任意数量的子代，但它只能有一个父代，或者可以直接放置在世界上。场景组件系统不支持附件循环。两种主要方法是`SetupAttachment`，它们在构造函数中以及与尚未注册的组件打交道时非常有用，以及`AttachToComponent`，它可以将一个Scene Component立即附加到另一个Scene Component，并且在播放过程中很有用。通过将一个Actor的根Component附加到属于另一个Actor的Component，该附加系统还可以使Actor彼此附加。

#### **UPrimitiveComponent**

PrimitiveComponents是具有某种图形表示形式（例如网格或粒子系统）的SceneComponents。许多有趣的物理和碰撞设置都在这里。

Actor支持具有SceneComponents的层次结构。每个Actor还具有一个`RootComponent`属性，该属性指定哪个Component充当Actor的根。Actor本身没有变换，因此没有位置，旋转或缩放。相反，他们依赖于其组件的转换。更具体地说，它们的根组件。如果此Component是**SceneComponent**，则它将提供Actor的转换信息。否则，Actor将没有任何变换。其他连接的零部件相对于其连接的零部件具有转换。

**基本组件**（class `UPrimitiveComponent`, a child of `USceneComponent`）是具有几何表示的场景组件，**通常用于渲染视觉元素或与物理对象碰撞或重叠。**其中包括静态或骨架网格物体，子画面或广告牌，粒子系统以及盒子，胶囊和球体的碰撞体积。

#### 注册组件

为了使Actor组件更新每一帧并影响场景，引擎必须对其进行注册。对于在该Actor的生成过程中作为Actor的子对象创建的组件，此操作会自动发生。但是，**手动注册可用于在播放过程中创建的组件**。该`RegisterComponent`功能提供此功能，并且要求组件与Actor相关联。

### Ticking

**Ticking指的是Actors的更新方式。**所有Actor都可以在每一帧或以最小的用户定义间隔被ticking，使您可以执行任何必要的更新计算或操作。

Actors all have the ability to be ticked by default via the `Tick()` function.

**ActorComponents**也使用功能来进行更新，但它们默认具有更新`TickComponent()`功能。

[组件更新](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Actors/Components/index.html#updating)

[ticking具体介绍](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Actors/Ticking/index.html)

## 委托

**引用和执行C++对象上的成员函数的数据类型。**

**委托**可以以通用的类型安全的方式在C ++对象上调用成员函数。委托可以动态绑定到任意对象的成员函数，即使将来调用者不知道对象的类型，也可以在将来对其调用该函数。委托可以安全复制。您也可以按值传递它们，但是不建议这样做，因为此过程将在堆上分配内存；尽可能通过引用传递委托。引擎支持三种类型的委托：

*单委托*

*[多播委托](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates/Multicast/index.html)*

*[动态委托](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates/Dynamic/index.html)*

动态委托可以序列化并支持反射的委托。

### 声明委托

要声明委托，请使用以下宏之一；根据您要绑定到委托的一个或多个函数的签名选择宏。每个宏均具有用于新替代类型名称的参数，以及函数的返回类型（如果不是`void`）及其参数。当前，委托签名支持以下任意组合：

函数有返回值

函数声明为const

最多四个有效负载变量

最多八个函数参数

| Function signature                   | Declaration macro                                            |
| :----------------------------------- | :----------------------------------------------------------- |
| `void Function()`                    | `DECLARE_DELEGATE(DelegateName)`                             |
| `void Function(Param1)`              | `DECLARE_DELEGATE_OneParam(DelegateName, Param1Type)`        |
| `void Function(Param1, Param2)`      | `DECLARE_DELEGATE_TwoParams(DelegateName, Param1Type, Param2Type)` |
| `void Function(Param1, Param2, ...)` | `DECLARE_DELEGATE_Params(DelegateName, Param1Type, Param2Type, ...)` |
| `Function()`                         | `DECLARE_DELEGATE_RetVal(RetValType, DelegateName)`          |
| `Function(Param1)`                   | `DECLARE_DELEGATE_RetVal_OneParam(RetValType, DelegateName, Param1Type)` |
| `Function(Param1, Param2)`           | `DECLARE_DELEGATE_RetVal_TwoParams(RetValType, DelegateName, Param1Type, Param2Type)` |
| `Function(Param1, Param2, ...)`      | `DECLARE_DELEGATE_RetVal_Params(RetValType, DelegateName, Param1Type, Param2Type, ...)` |

注意，委托函数支持和UFUNCTION一样的说明符，但使用`UDELEGATE`宏来代替`UFUNCTION`。

```c++
UDELEGATE(BlueprintAuthorityOnly)
DECLARE_DYNAMIC_MULTICAST_DELEGATE_FourParams(FInstigatedAnyDamageSignature, float, Damage, const UDamageType*, DamageType, AActor*, DamagedActor, AActor*, DamageCauser);
```

### 绑定委托

委托系统了解某些类型的对象，并且在使用这些对象时会启用其他功能。

| Function      | Description                                                  |
| :------------ | :----------------------------------------------------------- |
| `Bind`        | Binds to an existing delegate object.                        |
| `BindStatic`  | Binds a raw C++ pointer global function delegate.            |
| `BindRaw`     | Binds a raw C++ pointer delegate. Since raw pointers do not use any sort of reference, calling `Execute` or `ExecuteIfBound` after deleting the target object is unsafe. |
| `BindLambda`  | Binds a functor. This is generally used for lambda functions. |
| `BindSP`      | Binds a shared pointer-based member function delegate. Shared pointer delegates keep a weak reference to your object. You can use `ExecuteIfBound` to call them. |
| `BindUObject` | Binds a `UObject` member function delegate. `UObject` delegates keep a weak reference to the `UObject` you target. You can use `ExecuteIfBound` to call them. |
| `UnBind`      | Unbinds this delegate.                                       |

### Payload Data

绑定到委托时，您可以传递有效载荷数据。这些是任意变量，将在调用时直接传递给任何绑定的函数。这真的很有用，因为它允许您在绑定时将参数存储在委托本身中。所有委托类型（“动态”除外）都自动支持有效负载变量。

```c++
MyDelegate.BindRaw( &MyFunction, true, 20 );
```

### 执行委托

绑定到委托的`Execute()`函数通过调用委托的函数来执行。在执行委托之前，必须检查委托是否被“绑定”。这是为了使代码更安全，因为在某些情况下，委托的返回值和输出参数可能未初始化并随后被访问。在某些情况下，执行未绑定的委托实际上可能会占用内存。您可以致电`IsBound()`以检查委托是否可以安全执行。另外，对于没有返回值的委托，您可以调用`ExecuteIfBound()`，但是要警惕可能未初始化的输出参数。

| 执行功能         | 描述                                                |
| :--------------- | :-------------------------------------------------- |
| `Execute`        | 执行委托而不检查其绑定                              |
| `ExecuteIfBound` | 检查是否绑定了委托，如果是，则调用Execute。         |
| `IsBound`        | 通常在包含`Execute`调用的代码之前检查是否绑定了委托 |

[用法示例](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates/index.html)

### Events

Events与多播委托非常相似。然而，当任何一个类可以绑定事件，只有类声明了这个事件才可能调用事件的`Broadcast,IsBound,Clear`函数。这意味着事件对象可以在公共接口中公开，而不必担心让外部类访问这些敏感功能。事件的使用案例包括：包括纯粹的抽象类的回调，以及调用限制外部类`Broadcast`，`IsBound`和`Clear`功能。

#### 事件的声明

| 声明宏                                                       | 描述                     |
| :----------------------------------------------------------- | :----------------------- |
| `DECLARE_EVENT( OwningType, EventName )`                     | 创建一个事件。           |
| `DECLARE_EVENT_OneParam( OwningType, EventName, Param1Type )` | 用一个参数创建一个事件。 |
| `DECLARE_EVENT_TwoParams( OwningType, EventName, Param1Type, Param2Type )` | 用两个参数创建一个事件。 |
| `DECLARE_EVENT_Params( OwningType, EventName, Param1Type, Param2Type, ... )` | 创建具有N个参数的事件。  |

**DECLARE_EVENT`宏的第一个参数是将“拥有”此事件的类，因此可以调用该`Broadcast()`函数。**

#### 绑定事件

事件的绑定以与多播绑定相同的方式执行。

#### 事件的执行

事件允许您附加多个函数委托，然后通过调用事件的`Broadcast()`函数一次执行所有这些委托。事件签名不允许使用返回值。对于事件，`Broadcast()`只能由定义事件 的类调用。

`Broadcast()`即使未绑定任何事件，调用事件始终是安全的。唯一需要注意的是，如果您正在使用事件来初始化输出变量，通常这是很不好的事情。

`Broadcast()`未定义绑定函数在调用时的执行顺序。可能不按添加功能的顺序。

| 功能          | 描述                                               |
| :------------ | :------------------------------------------------- |
| `Broadcast()` | 将事件广播到所有绑定的对象，可能已过期的对象除外。 |

### 多播委托

**可以绑定到多个函数并一次执行它们的委托。**

多播代理与单播代理具有大多数相同的功能。它们仅对对象具有较弱的引用，可以与结构一起使用，可以轻松地进行复制等。与常规委托一样，多播委托可以被加载/保存和远程触发。但是，**多播委托函数不能使用返回值。它们最适合用来轻松地传递一组代表。**

Events是一种特殊类型的多播委托，对`Broadcast(),IsBound(),Clear()访问受限。

#### 声明多播委托

| 声明宏                                                       | 描述                     |
| :----------------------------------------------------------- | :----------------------- |
| `DECLARE_MULTICAST_DELEGATE``[_RetVal, etc.]( DelegateName )` | 创建一个多播委托。       |
| `DECLARE_DYNAMIC_MULTICAST_DELEGATE``[_RetVal, etc.]( DelegateName )` | 创建一个动态的多播委托。 |

#### 绑定多播委托

| 功能           | 描述                                                         |
| :------------- | :----------------------------------------------------------- |
| `Add()`        | 将函数委托添加到此多播委托的调用列表中。                     |
| `AddStatic()`  | 添加原始的C ++指针全局函数委托。                             |
| `AddRaw()`     | 添加原始的C ++指针委托。原始指针不使用任何类型的引用，因此，如果从您的委托下方删除该对象，则调用该指针可能是不安全的。调用Execute（）时要小心！ |
| `AddSP()`      | 添加一个基于共享指针的（快速的，不是线程安全的）成员函数委托。共享的指针委托对您的对象保持弱引用。 |
| `AddUObject()` | 添加基于UObject的成员函数委托。UObject委托对您的对象保持弱引用。 |
| `Remove()`     | 从此多播委托的调用列表中删除一个函数（性能为O（N））。请注意，委托的顺序可能不会保留！ |
| `RemoveAll()`  | 从此多播委托的调用列表中删除所有绑定到指定UserObject的函数。请注意，委托的顺序可能不会保留！ |

`RemoveAll()`将删除绑定到提供的指针的所有注册委托。请记住，未绑定到对象指针的Raw委托不会被该函数删除！

有关这些功能的变体，参数和实现，请参见`DelegateSignatureImpl.inl`（位于中`..\UE4\Engine\Source\Runtime\Core\Public\Delegates\`）。

#### 多播执行

多播委托允许您附加多个函数委托，然后通过调用组播委托的`Broadcast()`函数一次执行所有委托。不允许多播委托签名使用返回值。

`Broadcast()`即使没有绑定，调用多播委托始终是安全的。唯一需要注意的是，如果您正在使用委托来初始化输出变量，这通常很难做到。

`Broadcast()`未定义绑定函数在调用时的执行顺序。可能不按添加功能的顺序。

| 功能          | 描述                                                 |
| :------------ | :--------------------------------------------------- |
| `Broadcast()` | 将此委托广播到所有绑定的对象，可能已过期的对象除外。 |

## 对象(Objects)

Unreal中对象的基类是UObject。UCLASS可用于标记派生自UObject的类，以便UObject处理系统时可以识别它们。

### UCLASS宏

UCLASS宏为UObject提供了一个对UCLASS的引用，该UCLASS描述了它的Unreal-based的类型。每一个UCLASS维护一个对象，称为“Class Default Object”，简称CDO；CDO本质上是默认的“模板”对象，由类构造函数生成，此后未经修改。尽管通常应将UCLASS和CDO视为只读，但它们都可以针对给定的Object实例进行检索。可以使用GetClass（）函数随时访问对象实例的UCLASS。

UCLASS包含一组定义类的属性和函数。这些是本机代码可用的常规C ++函数和变量，但带有Unreal特定的元数据标记，这些元数据控制它们在对象系统中的行为。有关标记语法的更多详细信息，请参见《[编程参考》](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/index.html) 。

### 属性和函数类型

UObject可以具有成员变量（称为属性）或任何类型的函数。但是，为了使虚幻引擎能够识别和操作这些变量或函数，必须使用特殊的宏对其进行标记，并且必须符合某些类型标准。有关这些标准的详细信息，请参见“ [属性”](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Properties/index.html) 和“ [UFunctions”](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Functions/index.html) 参考页。

### 对象创建

有几个函数可以用来创建新`UObject`实例以及标准`new`运算符。每个都有自己的用例：

| 方法                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [`NewObject`](https://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/UObject/NewObject) | 使用所有可用创建选项的可选参数创建一个新实例。提供广泛的灵活性，包括带有自动生成名称的简单用例。 |
| `new`                                                        | 用于在某些低级情况下构造对象，例如当构造函数需要参数时。     |

### UObjects提供的功能

在所有情况下都不需要甚至不建议使用此系统，但是这样做有很多好处，包括：

- 垃圾收集
- 引用更新
- 反射
- 序列化
- 自动更新默认属性更改
- 自动属性初始化
- 自动编辑器集成
- 类型信息在运行时可用
- 网络复制

有关每个系统的更多详细信息，请参见[虚幻对象处理](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Objects/Optimizations/index.html) 文档。

### The Unreal Header Tool（UHT）

为了利用UObject派生的类型提供的功能，**需要在这些类型的头文件上运行预处理步骤**，以便整理所需的信息。此预处理步骤由UnrealHeaderTool（简称UHT）执行。

### 头文件格式

尽管UObject在源（.cpp）文件中的实现与任何其他C ++类一样，但其在标头（.h）文件中的定义必须遵循某种基本结构，才能与Unreal Engine 4正常配合使用。 “ New C ++ Class”命令是设置格式正确的头文件的最简单方法。假定将UObject派生类称为UMyObject并将创建它的项目称为MyProject，则派生自UObject的类的基本头文件可能如下所示：

```c++
#pragma once

#include 'Object.h'
#include 'MyObject.generated.h'

/**
 * 
 */
UCLASS()
class MYPROJECT_API UMyObject : public UObject
{
    GENERATED_BODY()

};
```

虚幻相关的部分如下：

```c++
#include "MyObject.generated.h"
```

该行应是文件中的最后#include指令。如果此头文件需要了解其他类，则可以在文件中的任何位置转发它们，也可以将其包含在MyObject.genic.h之上。

```c++
UCLASS()
```

UCLASS宏使UMyObject对Unreal Engine 4可见。该宏支持各种[类](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Classes/Specifiers/index.html) 说明符，这些说明符确定为该类打开或关闭哪些功能。

```c++
class MYPROJECT_API UMyObject : public UObject
```

如果MyProject希望将UMyObject类公开给其他模块，则必须指定MYPROJECT_API。这对于游戏项目将包含的模块或插件，并故意公开类以在多个项目中提供可移植的自包含功能最为有用。

```c++
GENERATED_BODY()
```

**GENERATED_BODY宏不带任何参数，而是设置该类以支持引擎所需的基础结构。所有UCLASS都需要它。**

### 更新对象

Ticking是指如何在ue4中更新对象。所有对象都可以在每一帧中被打勾，从而可以执行必要的更新计算和操作。、

对象不具有任何内置的更新功能。但是，可以在必要时通过`FTickableGameObject`使用`inherits`类说明符从类继承来添加此功能。然后`Tick()`，他们可以实现该功能，引擎将在每个帧中调用该功能。请注意，大多数游戏中的对象将是[Actors](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Actors/index.html) ，它们可以按用户设置的最小间隔进行滴答，而不是每帧一次。

### 销毁对象

请注意，[弱指针](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/SmartPointerLibrary/WeakPointer/index.html) 对对象是否被垃圾回收没有影响。

当不再引用对象时，垃圾回收系统会自动处理对象销毁。这意味着任何UPROPERTY指针，引擎容器或[智能指针](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/SmartPointerLibrary/index.html) 类实例都不应对此有任何强引用。运行垃圾收集器时，将删除找到的未引用对象。另外，`MarkPendingKill()`可以直接在对象上调用该函数，并且该函数会将指向该对象的所有指针设置为NULL，并从全局搜索中删除该对象。再一次，该对象将在下一次垃圾回收遍被完全删除。

## 字符串处理

### FName

在“ **内容浏览器”中**命名新资产，在“ 动态材质实例”中更改参数或访问“骨架网格物体”中的骨骼时，您正在使用**FNames**。FName提供了一种非常轻巧的系统来使用字符串，即使给定的字符串被重复使用，该字符串在数据表中也只会存储一次。

FName提供了一种非常轻巧的系统来使用字符串，即使给定的字符串被重复使用，该字符串在数据表中也只会存储一次。FName不区分大小写。它们是不可变的，不能被操纵。FName的存储系统和静态性质意味着可以快速地通过键查找和访问FName。FName子系统的另一个功能是使用哈希表为FName转换提供快速的字符串。

[FName参考指南](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/StringHandling/FName/index.html)

### FText

[FText指南](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/StringHandling/FText/index.html)

在虚幻引擎4（UE4）中，用于[文本本地化](https://docs.unrealengine.com/en-US/Gameplay/Localization/Formatting/index.html)的主要组件 是`FText`类。所有面向用户的文本都应使用此类，因为它通过提供以下功能来支持文本本地化：

- [创建本地化文本文字](https://docs.unrealengine.com/en-US/Gameplay/Localization/Formatting/index.html#textliterals) 。
- [格式化文本](https://docs.unrealengine.com/en-US/Gameplay/Localization/Formatting/index.html#textformatting) （从占位符模式生成文本）。
- [从数字生成文本](https://docs.unrealengine.com/en-US/Gameplay/Localization/Formatting/index.html#numericaltextgeneration) 。
- [从日期和时间生成文本](https://docs.unrealengine.com/en-US/Gameplay/Localization/Formatting/index.html#chronological) 。
- [生成派生的文本](https://docs.unrealengine.com/en-US/Gameplay/Localization/Formatting/index.html#transformative) ，例如使文本大写或小写。

### FString

与FName和FText不同，**FString**是唯一允许进行操作的字符串类。有很多方法可用于字符串处理，包括大小写更改，摘录子字符串和

1. 可以**搜索，修改**FString并将其与其他字符串进行比较。但是，这些操作会使FString比不可变的字符串类更昂贵。
2. [FString参考指南](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/StringHandling/FString/index.html)

### 编码方式

通常，设置字符串变量文字时应使用**TEXT（）**宏。如果未指定TEXT（）宏，则文字将使用ANSI编码，这在其支持的字符方面受到很大限制。传递给FString的所有ANSI文字都需要进行到TCHAR（本地Unicode编码）的转换，因此使用TEXT（）效率更高。

### 字符编码

假定的知识：[每个软件开发人员绝对，肯定地必须绝对了解Unicode和字符集（没有任何借口！）](http://www.joelonsoftware.com/articles/Unicode.html)

[详细总结](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/StringHandling/CharacterEncoding/index.html)

> **<html>
> <head>
> ****< meta http-equiv = “ Content-Type” content = “ text / html; charset = utf-8” >**

但是，该meta标记确实必须是<head>部分中的第一件事，因为一旦Web浏览器看到此标记，它将立即停止解析页面，并在使用您指定的编码重新解释整个页面后重新开始。

Character EncodingOverview of character encodings used in Unreal Engine.Unreal Engine 4.9
This document provides an overview of character encodings used by Unreal.

Assumed knowledge: The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)

#### Text Formats

**ASCII码**

介于32和126之间（包括0和9、10和13）的字符（P4类型的文本）（这在签入时通过P4触发器进行了验证）

**ANSI**

ASCII和当前代码页（例如西欧高ASCII）需要以二进制形式存储在P4服务器上。

**UTF-8**

由单个字节组成的字符串，可以使用特殊字符序列获取非ANSI字符。（ASCII的超集）（P4类型Unicode）

**UTF-16**

#### 关于二进制

| **优点**                                               | **缺点**                                                     |
| :----------------------------------------------------- | :----------------------------------------------------------- |
| 内部格式未定义；不论文件格式如何，都可以加载每个文件。 | 不可合并。要求此类型的所有文件均为独占签出。                 |
|                                                        | 内部格式未定义；每个文件可以采用不同的格式。                 |
|                                                        | P4会存储每个版本的全部内容，这可能会不必要地增加软件仓库的大小。 |

#### 关于TEXT

| 优点                           | 缺点                            |
| ------------------------------ | ------------------------------- |
| 可合并。不需要以独占方式签出。 | 非常有限；仅允许使用ASCII字符。 |

#### 关于UTF-8

| **优点**                                                     | **缺点**                                                     |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| 轻松访问我们将需要的所有字符。                               | 对于亚洲语言具有不同的内存配置文件。                         |
| 使用更少的内存。                                             | 在我们的Perforce服务器上未启用P4类型Unicode。                |
| 是ASCII的超集；纯ASCII字符串是完全有效的UTF-8字符串。        | 字符串操作更加复杂；必须解析字符串以执行与长度计算一样简单的操作。 |
| 当游戏检测到字符串为ASCII并将其输出时，仍然可以使用。        | 在亚洲地区，MSDev不能很好地处理除ASCII以外的任何事情。这就是为什么我们在办理登机手续时将文本验证为ASCII的原因。 |
| 如果我们确实具有启用Unicode的服务器，则这些文件将是可合并的，并且不需要排他签出。 |                                                              |
| 可以通过分析字符串（带或不带BOM）来检测字符串是否为UTF-8。   |                                                              |

#### 关于UTF-16

| **优点**                                                     | **缺点**                                                     |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| 轻松访问我们将需要的所有字符。                               | 使用更多的内存。                                             |
| 内存使用量是字符数的两倍（对于我们使用的字符，它们全部在[Basic Multilingual Plane中](http://en.wikipedia.org/wiki/Mapping_of_Unicode_character_planes) ）。 | 如果没有BOM，则很难检测到这种格式。                          |
| 字符串操作可以拆分/合并，而不必解析字符串。                  | 当游戏检测到字符串为ASCII并将其照原样输出时，此功能将不起作用（现在已在使用UTF-16验证程序签入时检测到该字符串）。 |
| 与游戏中使用的格式相同，无需翻译，解析或存储操作。           | 在亚洲地区，MSDev不能很好地处理除ASCII以外的任何事情。这就是为什么我们在办理登机手续时将文本验证为ASCII的原因。 |
| 可合并。不需要独家结帐。                                     |                                                              |
| C＃在内部使用UTF-16。                                        |                                                              |

## TArray

[详细描述和操作](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/TArrays/index.html)

## 游戏计时器

**计时器**安排在延迟后或一段时间内执行的操作。例如，您可能想要在获得加电道具后使玩家无敌，然后在10秒后恢复漏洞。或者，您可能希望在玩家穿过充满有毒气体的房间时每秒造成一次伤害。这样的动作可以通过使用计时器来实现。

### 计时器管理

在全局**计时器管理器**（类型为`FTimerManager`）中管理**计时器**。全局计时器管理器存在于**游戏实例**对象以及每个**World上**。计时器管理器使用两个主要功能来设置计时器：`SetTimer`和和`SetTimerForNextTick`，每个都有多个重载。每个对象都可以附加到任何类型的Object或Function委托，并且`SetTimer`可以根据需要定期进行重复。有关 这些功能的更多详细信息，请参见[Timer Manager API页面](https://docs.unrealengine.com/en-US/API/Runtime/Engine/FTimerManager)。

计时器可以与标准C ++函数指针[`TFunction`Objects](https://docs.unrealengine.com/en-US/API/Runtime/Core/GenericPlatform/TFunction) 或[Delegates一起使用](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates/index.html) 。

### 设置和清楚计时器

FTimerManager的SetTimer函数将设置一个计时器，以在延迟后调用一个函数或者委托，并且可以设置为无限期地重复该函数调用。这些函数将填写一个**计时器句柄**（类型`FTimerHandle`），可用于暂停（和恢复）倒计时，查询或更改剩余时间，甚至完全取消计时器。

计时器也可以设置为在下一帧运行，而不是定时间隔运行。这可以通过调用来完成`SetTimerForNextTick`，但是请注意，此函数不会填写计时器句柄。

要清除计时器，请将在`SetTimer`调用过程中填写的`FTimerHandle`传递给`FTimerManager`的函数`ClearTimer`。此时，计时器句柄将变为无效，并且可以重新使用它来管理新的计时器。`SetTimer`使用现有的计时器句柄进行调用将清除该计时器句柄引用的计时器，并将其替换为新的计时器句柄。

最后，可以通过调用清除与特定对象关联的所有计时器`ClearAllTimersForObject`。

`调用SetTimer`的rate小于或者等于0是等价于调用`ClearTimer`。

### 暂停和恢复计时器

`FTimerManager`函数`PauseTimer`使用计时器句柄来暂停正在运行的计时器。这样可以防止定时器执行其功能调用，但是暂停时经过的时间和剩余的时间保持不变。`UnPauseTimer`使暂停的计时器恢复运行。

### Is Timer Active

`IsTimerActive`函数用于确定指定的计时器是否当前处于活动状态以及未暂停。

### 计时器速率

`FTimerManager`具有一个称为`GetTimerRate`的函数，该函数从其计时器句柄获取计时器的当前速率（两次激活之间的时间）。不能直接更改计时器的速率，但`SetTimer`可以使用其计时器句柄调用它以清除它并创建一个新的计时器，除了该速率外，其他计时器可以相同。 如果计时器句柄无效，`GetTimerRate`则将返回的值`-1`。

### 经过事件和剩余时间

`FTimermanager`通过`GetTimerElapsed`和提供功能`GetTimerRemaining`，分别返回与提供的计时器句柄关联的计时器的经过时间和剩余时间。与一样`GetTimerRate`，`-1`如果计时器句柄无效，这些函数将返回。

## TMap

`TMap`也可以使用可选的分配器来控制内存分配行为。但是，不像`TArray`，这些是集合分配器，而不是像`FHeapAllocator`和`TInlineAllocator`那样的标准UE4分配器。集合分配器（class `TSetAllocator`）定义了映射应使用多少个哈希桶，以及哈希和元素存储应使用哪种标准的UE4分配器。

最后的`TMap`模板参数是`KeyFuncs`，它告诉地图如何从元素类型中检索键，如何比较两个键是否相等以及如何对键进行哈希处理。这些具有默认值，它们将仅返回对键的引用，`operator==`用于相等性，并调用非成员`GetTypeHash`函数进行哈希处理。如果您的键类型支持这些功能，则可以在不提供custom的情况下将其用作地图键`KeyFuncs`。

**其他使用大致与c++的差不多。用的时候看下格式**

## TSet

与tmap差不多，区别和c++中与map的区别相同。

## TSubclassOf

[详细](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/TSubclassOf/index.html)

## Unreal Object Handling(虚幻对象处理)

标志类，属性和功能与适当的宏把它们转化成`UClasses`，`UProperties`和`UFunctions`。这使虚幻引擎可以访问它们，从而可以实现许多后台处理功能。

### 属性自动初始化

`UObjects`在调用构造函数之前，会在初始化时自动归零。这对于整个班级`UProperties`来说都是如此，本地成员也是如此。随后可以在类构造函数中使用自定义值初始化成员。

### 自动更新引用

当`AActor`或`UActorComponent`被销毁或以其他方式从游戏中移除时，反射系统可见的所有对其的引用（`UProperty`指针和存储在诸如Unreal Engine容器类中的指针`TArray`）将自动为空。这是有好处的，因为它可以防止悬空的指针持久存在并在以后造成麻烦，但是这也意味着，如果其他一些代码破坏了指针，则`AActor`and `UActorComponent`指针可以变为空。这样做的最终好处是，空检查更可靠，因为它既可以检测标准情况下的空指针，也可以检测非空指针将指向已删除内存的情况。

重要的是要意识到此功能仅适用于存储在虚幻引擎容器类中或者被UPROPERTY标记的`UActorComponent`或`AActor`引用`UPROPERTY`。

**原生指针中存储的对象引用ue4是不知道的，也不会自动更新，也不会阻止垃圾回收。**

请注意，这并不意味着所有`UObject*`变量都必须为`UProperties`。如果要使用非a的对象指针`UProperty`，请考虑使用`TWeakObjectPtr`。这是一个“弱”指针，表示它不会阻止垃圾回收，但是可以在访问之前查询其有效性，如果指向的对象被销毁，则将其设置为null。

### Serialization（序列化）

当一个`UObject`序列化，所有的`UProperty`值将自动写入或读取，除非明确地标记为“暂时”或从后构造默认值不变。例如，您可以将一个`AEnemy`实例放置在一个级别中，将其“运行状况”设置为500，保存并成功重新加载它，而无需编写超出`UClass`定义的一行代码。

### 更新属性值

当`UClass`的 **类默认对象**（CDO）更改，引擎将尝试在加载类的所有实例时对这些实例应用这些更改。对于给定Object实例，如果更新的变量值与旧CDO中的值相匹配，则将更新为它在新CDO中保存的值。如果变量包含任何其他值，系统会假设这个值是故意设置的，这些更改将会被保留。

### Editor Integration

编辑器理解`UObject`和`UProperties`，编辑器可以自动公开这些值以供编辑，而不必编写特殊代码。这可以选择在蓝图视觉脚本系统中融入集成。有许多选项可以控制变量和函数的可访问性和公开。

### 运行时类型信息和类型转换

由于`UObject`是虚幻引擎反射系统的一部分，它们始终知道它们是哪些`UClass`，并可以在运行时做出有关类型的决定和类型转换。

[实例](https://docs.unrealengine.com/zh-CN/Programming/UnrealArchitecture/Objects/Optimizations/index.html)

### 垃圾回收

虚幻实现垃圾回收机制，不再被引用或已被显式标记为销毁的`UObject`将定期清除。引擎构建一个引用图表以确定哪些`UObject`仍在使用，哪些是孤立的。在该图表根部是一组指定为"根集"的`UObject`。任何`UObject`都可以添加到根集。当进行垃圾回收时，引擎将从根集开始，搜索已知`UObject`引用树来跟踪所有引用的`UObject`。任何未被引用的`UObject`（意味着未在树搜索中找到这些对象）将被假设为不再需要，因此被删除。

一个实际的影响是，您通常需要保持对希望保持活跃的任何Object的`UPROPERTY`引用，或者将指向它的指针存储在`TArray`或其他引擎容器类中。Actor及其组件通常属于例外情况，因为Actor通常被链接回到根集的Object引用（例如它们所属的关卡），而Actor的组件被Actor自身引用。Actor可以显式标记为销毁，方法是调用它们的`Destroy`函数，这是从进行中游戏移除Actor的标准方法。组件可以使用`DestroyComponent`函数显式销毁，但它们通常在拥有它们的Actor从游戏中移除时被销毁。

虚幻引擎4中的垃圾回收速度快，效率高，内置大量的优化功能，能够尽量降低开销，如多线程可访问性分析可以标识孤立Object，优化的反加密代码能够尽快从容器中移除Actor。还有一些其他功能以调节，以更精准地控制如何以及何时执行垃圾回收，大部分都可以在 **项目设置（Project Settings）** 中的 **引擎 垃圾回收（Engine Garbage Collection）** 下找到。以下设置通常用于为项目调节垃圾回收器性能：

[地址](https://docs.unrealengine.com/zh-CN/Programming/UnrealArchitecture/Objects/Optimizations/index.html)

### 网络复制

`UObject`系统包含一组可靠的功能，能够促进[网络通信和多人游戏](https://docs.unrealengine.com/zh-CN/Gameplay/Networking/index.html) 。

`UProperties`可以标记为告诉引擎[在网络游戏期间复制数据](https://docs.unrealengine.com/zh-CN/Gameplay/Networking/Actors/Properties/index.html) 。常见模型是一个变量在服务器上发生更改，引擎检测到这个更改，并将其可靠地发送到所有客户端。当变量通过复制发生更改时，客户端可以选择性接收回调函数。

`UFunctions`也可以标记为[在远程机器上执行](https://docs.unrealengine.com/zh-CN/Gameplay/Networking/Actors/RPCs/index.html) 。例如，"server"函数在客户端上调用时，将会在服务器上执行这个函数以获取服务器版本的Actor。而另一方面，"client"函数可以从服务器调用，并在拥有这个函数的客户端版本的对应Actor上运行。

## Unreal智能指针库

**虚幻智能指针库** 为C++11智能指针的自定义实现，旨在减轻内存分配和追踪的负担。该实现包括行业标准 **共享指针**、**弱指针** 和 **唯一指针**。其还可添加 **共享引用**，此类引用的行为与不可为空的共享指针相同。虚幻Objects使用更适合游戏代码的单独内存追踪系统，因此这些类无法与 `UObject` 系统同时使用。

### 智能指针类型

智能指针可影响其包含或引用对象的寿命。不同智能指针对对象有不同的限制和影响。下表可用于协助决定各类型智能指针的适用情况：

| 智能指针类型                                                 | 适用情形                                                     |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| **共享指针**（`TSharedPtr`）                                 | 共享指针拥有其引用的对象，无限防止该对象被删除，并在无共享指针或共享引用（见下文）引用其时，最终处理其的删除。共享指针可为空白，意味其不引用任何对象。任何非空共享指针都可对其引用的对象生成共享引用。 |
| **共享引用(Programming/UnrealArchitecture/SmartPointerLibrary/SharedReference)**（`TSharedRef`） | 共享引用的行为与共享指针类似，即其拥有自身引用的对象。对于空对象而言，其存在不同；共享引用须固定引用非空对象。共享指针无此类限制，因此共享引用可固定转换为共享指针，且该共享指针固定引用有效对象。要确认引用的对象是非空，或者要表明共享对象所有权时，请使用共享引用。 |
| **弱指针(Programming/UnrealArchitecture/SmartPointerLibrary/WeakPointer)**（TWeakPtr`TSharedPtr`） | 弱指针类与共享指针类似，但不拥有其引用的对象，因此不影响其生命周期。此属性中断引用循环，因此十分有用，但也意味弱指针可在无预警的情况下随时变为空。因此，弱指针可生成指向其引用对象的共享指针，确保程序员能对该对象进行安全临时访问。 |
| **唯一指针**（`TUniquePtr`）                                 | 唯一指针仅会显式拥有其引用的对象。仅有一个唯一指针指向给定资源，因此唯一指针可转移所有权，但无法共享。复制唯一指针的任何尝试都将导致编译错误。唯一指针超出范围时，其将自动删除其所引用的对象。 |

| 优点                   | 描述                                                         |
| :--------------------- | :----------------------------------------------------------- |
| **防止内存泄漏**       | 共享引用不存在时，智能指针（弱指针除外）会自动删除对象。     |
| **弱引用**             | 弱指针会中断引用循环并阻止悬挂指针。                         |
| **可选择的线程安全**） | 虚幻智能指针库包括线程安全代码，可跨线程管理引用计数。如无需线程安全，可用其换取更好性能。 |
| **运行时安全**         | 共享引用从不为空，可固定随时取消引用。                       |
| **授予意图**           | 可轻松区分对象所有者和观察者。                               |
| **内存**               | 智能指针在64位下仅为C++指针大小的两倍（加上共享的16字节引用控制器）。唯一指针除外，其与C++指针大小相同。 |

### 助手类和函数

虚幻智能指针库提供多个助手类和函数，以便使用智能指针时更加容易、直观。

| 助手                                           | 描述                                                         |
| :--------------------------------------------- | :----------------------------------------------------------- |
| 类                                             |                                                              |
| `TSharedFromThis`                              | 在添加 `AsShared` 或 `SharedThis` 函数的 `TSharedFromThis` 中衍生类。利用此类函数可获取对象的 `TSharedRef`。 |
| 函数                                           |                                                              |
| `MakeShared` 和 `MakeShareable`                | 在常规C++指针中创建共享指针。`MakeShared` 会在单个内存块中分配新的对象实例和引用控制器，但要求对象提交公共构造函数。`MakeShareable` 的效率较低，但即使对象的构造函数为私有，其仍可运行。利用此操作可拥有非自己创建的对象，并在删除对象时支持自定义行为。 |
| `StaticCastSharedRef` 和 `StaticCastSharedPtr` | 静态投射效用函数，通常用于向下投射到衍生类型。               |
| `ConstCastSharedRef` 和 `ConstCastSharedPtr`   | 将 `const` 智能引用或智能指针分别转换为 `mutable` 智能引用或智能指针。 |

### 侵入性访问器

共享指针是非侵入性的，意味对象不知道其是否为智能指针拥有。但在某些情况下，可能要将对象作为共享引用或共享指针进行访问。为此，使用对象的类作为模板参数，在 `TSharedFromThis` 衍生对象的类。`TSharedFromThis` 提供两个函数：`AsShared` 和 `SharedThis`，可将对象转换为共享引用（并从共享引用转换为共享指针）。

**未看懂**

### 共享引用

[共享引用](https://docs.unrealengine.com/zh-CN/Programming/UnrealArchitecture/SmartPointerLibrary/SharedReference/index.html)

### 弱指针

**弱指针** 存储对象的弱引用。与 **共享指针** 或 **共享引用** 不同，弱指针不会阻止其引用的对象被销毁。

[具体](https://docs.unrealengine.com/zh-CN/Programming/UnrealArchitecture/SmartPointerLibrary/WeakPointer/index.html)

## 网络概述

在多人游戏会话中，游戏状态信息将通过互联网连接在多台机器之间通信，而非单独驻留于一台计算机上。玩家之间的信息共享十分微妙，并会增加部分额外步骤，因此此操作导致多人游戏编程比单人游戏编辑复杂。

### 尽早规划多人游戏

相较于初期规划，在项目后期引入网络功能会占用大量资源，且极为复杂。因此，除非确定项目无需多人游戏功能，否则应始终按多人游戏方向进行编程。

### 客户端-服务器模型

服务器作为游戏主机，保留一个真实 **授权** 的游戏状态。换句话说，服务器是多人游戏实际发生的地方。客户端会远程控制其在服务器上各自拥有的 **Pawn**，发送过程调用以使其执行游戏操作。但服务器不会将视觉效果直接流送至客户端显示器。服务器会将游戏状态信息 **复制** 到各客户端，告知应存在的Actor、此类Actor的行为，以及不同变量应拥有的值。然后各客户端使用此信息，对服务器上正在发生的情况进行高度模拟。

[详细指南](https://docs.unrealengine.com/zh-CN/Gameplay/Networking/Server/index.html)

### 网络模式和服务器类型

| 网络模式       | 说明                                                         |
| :------------- | :----------------------------------------------------------- |
| **独立**       | 游戏作为服务器运行，不接受远程客户端连接。参与游戏的玩家必须为本地玩家。此模式用于单人游戏和本地多人游戏。其将运行本地玩家适用的服务器逻辑和客户端逻辑。 |
| **客户端**     | 游戏作为网络多人游戏会话中与服务器连接的客户端运行。其不会运行服务器逻辑。 |
| **聆听服务器** | 游戏作为主持网络多人游戏会话的服务器运行。其接受远程客户端中的连接，且直接在服务器上拥有本地玩家。此模式通常用于临时合作和竞技多人游戏。 |
| **专属服务器** | 游戏作为主持网络多人游戏会话的服务器运行。其接受远程客户端中的连接，但无本地玩家，因此为了高效运行，其将废弃图形、音效、输入和其他面向玩家的功能。此模式常用于需要更固定、安全和大型多人功能的游戏。 |

拥有游戏副本的用户均可启动聆听服务器并在同一计算机上运行，因此聆听服务器对于用户而言较易自发设置。支持聆听服务器的游戏通常拥有游戏UI，用于启动服务器或搜索要加入的服务器。但由于主持聆听服务器的玩家会直接在服务器上游戏，因此比其他必须使用网络连接方可游戏的玩家更具优势，于是便导致了公平和作弊问题。同时，要作为服务器运行，还需支持如图形和音效等玩家相关系统，从而引发额外处理负载。此类因素导致聆听服务器不适用于激烈的竞技或网络负载极高的游戏，但对于小型玩家群体间进行临时合作和竞技多人游戏而言，却十分好用。

专属服务器成本更高，更难以配置，需要独立于所有参与玩家的计算机，并需要完成自身网络连接。但所有加入专属服务器的玩家均使用相同类型的连接进行游戏，从而保证了公平性。由于专属服务器不会渲染图形或执行仅与本地玩家相关的其它逻辑，因此还可高效处理gameplay和网络。因此，出于安全、公平或可靠方面的原因，专属服务器更适用于需要大量玩家或需要高效执行、可信服务器的游戏。此类游戏包括MMO、竞技MOBA，或快节奏网络射击游戏。

### Actor复制

[Actor复制](https://docs.unrealengine.com/zh-CN/Gameplay/Networking/Overview/index.html)

[详细指南](https://docs.unrealengine.com/zh-CN/Gameplay/Networking/Actors/index.html)

复制是指在网络会话中的不同机器间复制游戏状态信息。若正确设置复制，将可同步不同机器的游戏实例。多数Actor默认不会启用复制，且将本地执行所有功能。在C++ Actor类中设置 `bReplicates` 变量，或将Actor蓝图的 **复制（Replicates）** 设置设为 **true**，可启用给定类的Actor复制。

常见复制功能

| 复制功能                | 说明                                                         |
| :---------------------- | :----------------------------------------------------------- |
| **创建和销毁**          | 服务器上生成复制Actor的授权版本时，其会在所有连接客户端上自动生成远程代理。其之后会将信息复制到这些远程代理。若销毁授权Actor，则将自动销毁所有连接客户端上的远程代理。 |
| **移动复制**            | 若授权Actor启用了 **复制移动**，或将C++中的 `bReplicateMovement` 设为 `true`，其将自动复制位置、旋转和速度。 |
| **变量复制**            | 在指定为复制变量的值变更时，其将自动从授权Actor复制到其远程代理。 |
| **组件复制**            | Actor组件复制为其所属Actor的一部分。组件内指定为复制变量将复制，而组件内调用的RPC将与Actor类中调用的RPC保持一致。 |
| **远程过程调用（RPC）** | RPC是传输到网络游戏中特定机器的特殊函数。无论初始调用RPC的是哪台机器，其的实现仅在目标机器上运行。此类RPC可指定为服务器（仅在服务器上运行）、客户端（仅在Actor的拥有客户端上运行）或NetMulticast（在连接会话的所有机器上运行，包括服务器）。 |

虽然创建、销毁和移动等常见使用可自动处理，但即使启用复制，其他所有gameplay功能也不会默认自动复制。

### 网络角色和授权

Actor的 **网络角色** 将决定网络游戏期间控制Actor的机器。**授权** Actor被认为可控制Actor的状态，并可将信息复制到网络多人游戏会话中的其他机器上。**远程代理** 是该Actor在远程机器上的副本，其将接收授权Actor中的复制信息。其由 **Local Role** 和 **Remote Role** 变量进行追踪，可取以下值：

| 网络角色     | 说明                                                         |
| :----------- | :----------------------------------------------------------- |
| **无**       | Actor在网络游戏中无角色，不会复制。                          |
| **授权**     | Actor为授权状态，会将其信息复制到其他机器上的远程代理。      |
| **模拟代理** | Actor为远程代理，由另一台机器上的授权Actor完全控制。网络游戏中如拾取物、发射物或交互对象等多数Actor将在远程客户端上显示为模拟代理。 |
| **自主代理** | Actor为远程代理，能够本地执行部分功能，但会接收授权Actor中的矫正。自主代理通常为玩家直接控制的actor所保留，如pawn。 |

### 客户端拥有权

特定客户端机器上的 **PlayerController** 拥有网络游戏中的pawn。Pawn调用纯客户端函数时，其将无视调用函数的机器，而仅指向拥有玩家的机器。若将Actor的 **Owner** 变量设为特定Pawn，则通关关联，该Actor属于该Pawn的拥有客户端，并将纯客户端函数指向其拥有者的机器。可使用C++中的 `IsLocallyControlled` 函数，或蓝图中的 **Is Locally Controlled** 节点，以决定Pawn是否在其拥有客户端上。

### 相关性和优先级

**相关性** 用于决定是否需要在多人游戏期间复制Actor。复制期间将剔除被认为不相关的actor。此操作可节约带宽，以便相关Actor可更加高效地复制。若Actor未被玩家拥有，且不在玩家附近，将其被视为不相关，而不会进行复制。不相关Actor会存在于服务器上，且会影响授权游戏状态，但在玩家靠近前不会向客户端发送信息。覆盖 `IsNetRelevantFor` 函数以手动控制相关性，并可使用 `NetCullDistanceSquared` 属性决定成为相关Actor所需距离。

有时在游戏单帧内，没有足够带宽供复制所有相关Actor。因此，Actor拥有 **优先级（Priority）** 值，用于决定优先复制的Actor。Pawn和PlayerController的 `NetPriority` 默认为 **3.0**，从而使其成为游戏中最高优先级的Actor，而基础Actor的 `NetPriority` 为 **1.0**。Actor在被复制前经历的时间越久，每次成功通过时所处的优先级便越高。

### 变量复制

在C++中使用对应 `UPROPERTY` 宏内的 `Replicated` 或 `ReplicateUsing` 说明符，或在蓝图的细节面板中将它们指定为已复制，可将复制添加到变量和对象引用。授权Actor上复制变量的值变更时，其信息将自动从授权Actor发送到连接会话的远程代理。

#### RepNotify

可指定在Actor成功接收特定变量的复制信息时要调用的 **RepNotify** 函数。RepNotify仅在变量更新时本地触发。触发gameplay逻辑响应授权Actor上的变量更改时，使用RepNotify可减少开销。在C++中使用变量的 `UPROPERTY` 宏的 `ReplicatedUsing` 说明符可访问此功能，或修改蓝图中变量的复制设置以使用RepNotify。

### 远程过程调用(RPC)

远程过程调用也称为复制函数。可在任何机器上进行调用，但会指示其的实现在与网络会话连接的特定机器上发生。有三种RPC：

| RPC类型          | 说明                                                         |
| :--------------- | :----------------------------------------------------------- |
| **Server**       | 仅在主持游戏的服务器上调用。                                 |
| **Client**       | 仅在拥有该函数所属Actor的客户端上调用。若Actor无拥有连接，将不会执行此逻辑。 |
| **NetMulticast** | 在与服务器连接的所有客户端及服务器本身上调用。               |

[具体例子](https://docs.unrealengine.com/zh-CN/Gameplay/Networking/Overview/index.html)

### 提示

在游戏中实现高效、稳定多人游戏系统的基本指南如下。

#### 基本复制Actor清单

按照以下步骤，可创建复制Actor：

- 将Actor的复制设置设为True。
- 若复制Actor需要移动，将复制移动（Replicates Movement）设为True。
- 生成或销毁复制Actor时，确保在服务器上执行该操作。
- 设置必须在机器间共享的变量，以便进行复制。这通常适用于以gameplay为基础的变量。
- 尽量使用虚幻引擎的预制移动组件，其已针对复制进行构建。
- 若使用服务器授权模型，需确保玩家可执行的新操作均由服务器函数触发。

https://zhuanlan.zhihu.com/insideue4
https://zhuanlan.zhihu.com/c_104089875
https://zhuanlan.zhihu.com/c_164452593

https://zhuanlan.zhihu.com/p/34256771

## Actor 的 Role 和 RemoteRole 属性

https://docs.unrealengine.com/zh-CN/Gameplay/Networking/Actors/Roles/index.html