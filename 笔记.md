* 创建FName

  ```c++
  FName TestFName=FName(TEXT("DSADSADSA"));
  static const FName LoadingScreenName(TEXT("/Game/UI/Menu/LoadingScreen.LoadingScreen"));
  ```

* TSharedPtr

  一个非侵入的引用计数的权威对象指针

  ```c++
  /** loading screen image brush */
  TSharedPtr<FSlateDynamicImageBrush> LoadingScreenBrush;
  
  
  //
  void Construct(const FArguments& InArgs)
  {
  	static const FName LoadingScreenName(TEXT("/Game/UI/Menu/LoadingScreen.LoadingScreen"));
  
  	//since we are not using game styles here, just load one image
  	LoadingScreenBrush = MakeShareable( new FShooterGameLoadingScreenBrush( LoadingScreenName, FVector2D(1920,1080) ) );
  ```

* **UE4中的枚举**

  两种方式:

  [摘自知乎](https://zhuanlan.zhihu.com/p/68704087)

  ```c++
  UENUM()
  namespace EWeapon
  {
  	enum Type{
  		EW_Handgun;
  		EW_Shotgun;
  	};
  }
  
  UENUM()
  enum class EWeapon:uint8
  {
      EW_Handfun;
      EW_Shotgun;
  }
  ```

  对于枚举中的元素，可以使用UMEAT进行修饰：

  ```c++
  //必须添加BlueprintType标识
  UENUM(BlueprintType)
  enum class EWeapon : uint8
  {
  	EW_Handgun        UMETA(DisplayName="Handgun"),//如果想要显示中文，需要设置编码格式为UTF-8
  	EW_shotgun        UMETA(DisplayName="shotgun"),
  };
  ```

  枚举索引可以不从0开始：

  ```c++
  UENUM(BlueprintType)
  enum class EWeapon : uint8
  {
  	EW_Handgun =1        UMETA(DisplayName="Handgun"),
  	EW_shotgun           UMETA(DisplayName="shotgun"),
  };
  ```

  获取枚举指针:

  ```c++
  const UEnum *Enumptr=FindObejct<UEnum>(ANY_PACKAGE,TEXT('EWeapon'),true);
  ```

  [UENUM具体文档](https://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/UObject/UEnum/index.html)

* USTRUCT

  [USTRUCT具体文档](https://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/UObject/UStruct/index.html)

* 反射机制

  程序运行时，对于任何一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态的获取信息以及动态调用对象的方法的功能称为反射。反射数据描述了类在运行时的内容，这些数据所存储的信息包括类的名称、类中的数据成员、每个数据成员的类型等。

  具体来看，对于一个类（UClass），我们可以获得这个类的所有属性和方法，而对于一个类对象（UObject），我们可以调用它所拥有的方法和属性，前提是这些属性和方法被纳入到UE4的反射系统。于是，虚幻4使用反射可以实现序列化、editor的details panel、垃圾回收、网络复制、蓝图/C++通信和相互调用等功能。

  反射系统是**选择加入**的。

  UObject是反射系统的核心。每一个继承UObject且支持反射系统的类型都有一个相应的UClass，或者它的子类，UClass中包含了该类的描述信息。UObject与UClass也组成了UE4对象系统的基石，相关内容可以查看UE4对象系统的分析。

* GENERATED_BODY()等都是作为宏定义，最终是链接一串字符串

* 这里需要注意的是，## 在C++宏定义中，这里表示的是字符串的连接。 记住这行：// ##和# 的使用，##链接，#把字符变为字符串 

* 观察者模式
  * 简要概括来说，指的是当被观察者改动后，会触发这个被观察者的所有观察者的一个操作。

* Delegate
  * Delegate所起的作用是把一个对象与其函数绑定起来，从而产生一个可以全局调用的函数。

* ue4中的委托

  * 一种用以引用和执行C++对象上的成员函数的数据类型。

  * **委托**可以以通用的类型安全的方式在C ++对象上调用成员函数。可以将委托动态绑定到任意对象的成员函数，即使将来调用者不知道对象的类型，也可以在将来对其进行调用。委托可以安全复制。您也可以按值传递它们，但是不建议这样做，因为此过程将在堆上分配内存；尽可能通过引用传递委托。引擎支持三种类型的委托：

    * 单委托

    * 多播

      ```c++
      //ShooterCharacter.h 
      DECLARE_MULTICAST_DELEGATE_TwoParams(FOnShooterCharacterEquipWeapon, AShooterCharacter*, AShooterWeapon* /* new */);
      DECLARE_MULTICAST_DELEGATE_TwoParams(FOnShooterCharacterUnEquipWeapon, AShooterCharacter*, AShooterWeapon* /* old */);
      ```

      

    * 动态

* 关于反射和委托