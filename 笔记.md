### 创建FName

```c++
FName TestFName=FName(TEXT("DSADSADSA"));
static const FName LoadingScreenName(TEXT("/Game/UI/Menu/LoadingScreen.LoadingScreen"));
```

* TSharedPtr

  一个非侵入的引用计数的权威对象指针

  ```c++
  /** loading screen image brush */
  TSharedPtr<FSlateDynamicImageBrush> LoadingScreenBrush;
  
  
  //
  void Construct(const FArguments& InArgs)
  {
  	static const FName LoadingScreenName(TEXT("/Game/UI/Menu/LoadingScreen.LoadingScreen"));
  
  	//since we are not using game styles here, just load one image
  	LoadingScreenBrush = MakeShareable( new FShooterGameLoadingScreenBrush( LoadingScreenName, FVector2D(1920,1080) ) );
  ```

* **UE4中的枚举**

  两种方式:

  [摘自知乎](https://zhuanlan.zhihu.com/p/68704087)

  ```c++
  UENUM()
  namespace EWeapon
  {
  	enum Type{
  		EW_Handgun;
  		EW_Shotgun;
  	};
  }
  
  UENUM()
  enum class EWeapon:uint8
  {
      EW_Handfun;
      EW_Shotgun;
  }
  ```

  对于枚举中的元素，可以使用UMEAT进行修饰：

  ```c++
  //必须添加BlueprintType标识
  UENUM(BlueprintType)
  enum class EWeapon : uint8
  {
  	EW_Handgun        UMETA(DisplayName="Handgun"),//如果想要显示中文，需要设置编码格式为UTF-8
  	EW_shotgun        UMETA(DisplayName="shotgun"),
  };
  ```

  枚举索引可以不从0开始：

  ```c++
  UENUM(BlueprintType)
  enum class EWeapon : uint8
  {
  	EW_Handgun =1        UMETA(DisplayName="Handgun"),
  	EW_shotgun           UMETA(DisplayName="shotgun"),
  };
  ```

  获取枚举指针:

  ```c++
  const UEnum *Enumptr=FindObejct<UEnum>(ANY_PACKAGE,TEXT('EWeapon'),true);
  ```

  [UENUM具体文档](https://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/UObject/UEnum/index.html)

* USTRUCT

  [USTRUCT具体文档](https://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/UObject/UStruct/index.html)

* 反射机制

  程序运行时，对于任何一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态的获取信息以及动态调用对象的方法的功能称为反射。反射数据描述了类在运行时的内容，这些数据所存储的信息包括类的名称、类中的数据成员、每个数据成员的类型等。

  具体来看，对于一个类（UClass），我们可以获得这个类的所有属性和方法，而对于一个类对象（UObject），我们可以调用它所拥有的方法和属性，前提是这些属性和方法被纳入到UE4的反射系统。于是，虚幻4使用反射可以实现序列化、editor的details panel、垃圾回收、网络复制、蓝图/C++通信和相互调用等功能。

  反射系统是**选择加入**的。

  UObject是反射系统的核心。每一个继承UObject且支持反射系统的类型都有一个相应的UClass，或者它的子类，UClass中包含了该类的描述信息。UObject与UClass也组成了UE4对象系统的基石，相关内容可以查看UE4对象系统的分析。

* GENERATED_BODY()等都是作为宏定义，最终是链接一串字符串

* 这里需要注意的是，## 在C++宏定义中，这里表示的是字符串的连接。 记住这行：// ##和# 的使用，##链接，#把字符变为字符串 

* 观察者模式
  
* 简要概括来说，指的是当被观察者改动后，会触发这个被观察者的所有观察者的一个操作。
  
* Delegate
  
* Delegate所起的作用是把一个对象与其函数绑定起来，从而产生一个可以全局调用的函数。
  
* ue4中的委托

  * 一种用以引用和执行C++对象上的成员函数的数据类型。

  * **委托**可以以通用的类型安全的方式在C ++对象上调用成员函数。可以将委托动态绑定到任意对象的成员函数，即使将来调用者不知道对象的类型，也可以在将来对其进行调用。委托可以安全复制。您也可以按值传递它们，但是不建议这样做，因为此过程将在堆上分配内存；尽可能通过引用传递委托。引擎支持三种类型的委托：

    * 单委托

    * 多播

      ```c++
      //ShooterCharacter.h 
      DECLARE_MULTICAST_DELEGATE_TwoParams(FOnShooterCharacterEquipWeapon, AShooterCharacter*, AShooterWeapon* /* new */);
      DECLARE_MULTICAST_DELEGATE_TwoParams(FOnShooterCharacterUnEquipWeapon, AShooterCharacter*, AShooterWeapon* /* old */);
      ```

      

    * 动态

* 关于反射和委托

###  游戏模块

* 引擎本身由一组模块组成，每个游戏都由一个或多个模块组成。在ue4中，由于游戏都是由c++完成的，因此模块实际上是DLL，而不是专有的软件包文件。

* 游戏模块必须包括头文件，c++文件，和构建文件(*.Build.cs)
* 头文件必须位于模块目录的“公共”文件夹中，即[GameName] \ Source \ [ModuleName] \ Public。该文件包括编译模块中包含的类所需的所有头文件-包括模块的自动生成的头。
* C ++文件放置在模块目录的“专用”文件夹中，即[GameName] \ Source \ [ModuleName] \ Private，注册并实现该模块。
* 构建文件放置在游戏模块的根目录中，即[GameName] \ Source \ [ModuleName]，它定义了UnrealBuildTool用来编译模块的某些信息。
* [INI文件设置](https://docs.unrealengine.com/en-US/Programming/Modules/Gameplay/index.html)
* 您可以创建一个主要的游戏模块，然后创建任意数量的其他特定于游戏的模块。您可以为这些新模块创建* .Build.cs文件，然后将对这些模块的引用添加到游戏的[Target.cs文件](https://docs.unrealengine.com/en-US/Programming/BuildTools/UnrealBuildTool/TargetFiles/index.html) （OutExtraModuleNames数组）中。确保在C ++代码中为游戏模块使用适当的宏。至少一个模块必须使用IMPLEMENT_PRIMARY_GAME_MODULE宏，而其他模块都应使用IMPLEMENT_GAME_MODULE宏。然后，UBT应该自动发现模块并编译其他游戏DLL文件。

### **游戏类**

* 命名方案
  * 字首为A，含义为从可生成的(spawnable)游戏对象的基类扩展。这些都是Actors，可以直接产生(be spawned)到世界上。
  * 字首为U，含义为从所有游戏对象的基建类扩展，**这些不能被直接实例化为世界，他们必须属于一个Actor。这些通常是类似components的对象。

* 类的头文件

  * 游戏类通常都有一个单独且唯一的类头文件，这些头文件通常的名字是类名减去前缀U或者A。

  * 游戏类的类头文件将标准C ++语法与专用宏结合使用，以简化声明类，变量和函数的过程。

  * 在每个游戏类标题文件的顶部，需要包括生成的标题文件（自动创建）。因此，在的顶部`ClassName.h`，必须出现以下行：

    ```c++
    #include "ClassName.generated.h"
    ```

* 类的声明

  * 类声明定义了类的名称，它从哪个类继承以及由此继承到的任何函数和变量。

  * 类声明还定义了通过[类说明符](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Classes/index.html#classspecifiers) 和元数据可能需要的其他特定于引擎和编辑器的行为。

  * 语法如下:

    ```
    UCLASS([specifier, specifier, ...], [meta(key=value, key=value, ...)])
    class ClassName : public ParentName
    {
        GENERATED_BODY()
    }
    ```

    

  * 在上述的标准声明中，描述符如类说明符和元数据被传递给UCLASS

    这些用于创建`UClass`要声明的类的，可以将其视为引擎对类的专门表示。同样，`GENERATED_BODY()` 宏必须放在类主体的最开始。

  * 声明类的时候，类说明符可以添加到声明中来控制类的行为，在引擎和编辑器的各个方面。

  * 部分类说明符

    | 说明符        | 作用                                                         |
    | ------------- | ------------------------------------------------------------ |
    | Blueprintable | 将此类公开为创建蓝图的可接受基类。默认值为`NotBlueprintable`，除非以其他方式继承。该说明符由子类继承。 |
    | BlueprintType | 将此类公开为可用于蓝图中变量的类型。                         |
    | EditInlineNew | 指示可以从“虚幻编辑器属性”窗口中创建此类的对象，而不是从现有资产中进行引用。默认行为是只能通过“属性”窗口分配对现有对象的引用。此说明符传播到所有子类。子类可以使用`NotEditInlineNew`Specifier 覆盖它。 |

  * 在声明类，接口，结构，枚举，枚举值，函数或属性时，可以添加**元数据说明符**来控制它们在引擎和编辑器各个方面的行为。每种类型的数据结构或成员都有其自己的元数据说明符列表。[网页](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Classes/index.html)

* 类的实现
  * **所有游戏类必须GENERATED_BODY才能正确实现。**
  * **源文件必须包含C++类声明的头文件**

* 类构造

  * `UObjects`使用**构造函数**设置属性和其他变量的默认值以及执行其他必要的初始化。通常将类构造函数放置在类实现文件中，例如，`AActor::AActor`构造函数位于中`Actor.cpp`。
  * 也可以将构造函数内联放置在类头文件中。但是，如果构造函数在类头文件中，则必须用说明`CustomConstructor` 符声明UClass，因为这会阻止自动代码生成器在头文件中创建构造函数声明。

  * UObject构造函数的最基本形式如下所示：

    ```c++
    UMyObject::UMyObject()
    {
        // Initialize Class Default Object properties here.
    }
    ```

    该构造函数初始化类默认对象（Class Default Object,CDO),他是该类将来的实例所属的主副本。还有一个辅助构造函数，它支持特殊的属性更改结构：

    ```c++
    UMyObject::UMyObject(const FObjectInitializer& ObjectInitializer)
    : Super(ObjectInitializer)
    {
        // Initialize CDO properties here.
    }
    ```

    尽管上述构造函数均未实际执行任何初始化，但是引擎已将所有字段初始化为零，NULL或它们的默认构造函数实现的任何值。但是，任何写入构造函数的初始化代码都将应用于CDO，因此将被复制到在引擎中正确创建的对象的任何新实例，如 `CreateNewObject`或`SpawnActor`。

  * 构造函数的静态函数和辅助函数。

    为更复杂的数据类型（尤其是类引用，名称和资产引用）设置值时，需要在**构造**函数中定义并实例化一个**ConstructorStatics**结构，以容纳所需的各种属性值。`ConstructorStatics`仅在首次运行构造函数时创建此结构。在随后的运行中，它仅复制一个指针，这使其非常快。`ConstructorStatics`创建该结构时，将值分配给该结构的成员，以便稍后在构造函数中将值分配给实际属性本身时进行访问。

    **ContructorHelpers**是定义的特殊名称空间，`ObjectBase.h`其中包含用于执行特定于构造函数的常见操作的帮助程序模板。例如，有一些帮助程序模板，用于查找对资产或类的引用以及创建和查找组件。

    [示例代码](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Classes/index.html)

  * 类引用

    `ConstructorHelpers::FClassFinder`查找对指定对象的引用，`UClass`如果找不到该类，则报告失败。

    ```
    APylon::APylon(const class FObjectInitializer& ObjectInitializer)
    : Super(ObjectInitializer)
    {
        // Structure to hold one-time initialization
        static FClassFinder<UNavigationMeshBase> ClassFinder(TEXT("class'Engine.NavigationMeshBase'"));
        if (ClassFinder.Succeeded())
        {
            NavMeshClass = ClassFinder.Class;
        }
        else
        {
            NavMeshClass = nullptr;
        }
    }
    ```

    在许多情况下，您可以完全使用`USomeClass::StaticClass()`和跳过ClassFinder的复杂性。例如，在大多数情况下，您可以使用以下方法：

    ```c++
    NavMeshClass = UNavigationMeshBase::StaticClass();
    ```

  * 组件和子对象

    创建组件子对象并将其附加到参与者的层次结构也可以在构造函数内部完成。当生成一个actor时，其组件将从CDO中克隆。为了确保始终创建，销毁和正确收集组件，应将指向构造函数中创建的每个组件的指针存储在所属类的UPROPERTY中。

* UFUNCTION声明

  * **UFNCTION是受UE4反射系统识别的C++函数。**

  * 任何函数库或者蓝图函数库都可以通过将UFUNCTION宏放在头文件中函数声明上方的行上来将成员函数声明为UFUNCTION。

  * 该宏支持功能说明符，以更改UE4解释和使用功能的方式。

    ```c++
    UFUNCTION([specifier1=setting1, specifier2, ...], [meta(key1="value1", key2, ...)])
    ReturnType FunctionName([Parameter1, Parameter2, ..., ParameterN1=DefaultValueN1, ParameterN2=DefaultValueN2]) [const];
    ```

  * 使用功能说明符，您可以将UFunction公开给[Blueprint Visual Scripting](https://docs.unrealengine.com/en-US/Engine/Blueprints/index.html) 图形，这为开发人员提供了一种从Blueprint Assets调用或扩展UFunction的方法，而无需更改C ++代码。UFunction能够 在Class的默认属性中绑定到[Delegates](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates/index.html)，从而使它们能够执行诸如将动作与用户输入相关联的任务。它们还可以充当网络回调，这意味着只要某个变量受网络更新影响，您就可以使用它们来接收通知并运行自定义代码。

    [功能说明符和元数据说明符](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Functions/index.html)

  * 函数参数说明符

    | 参数说明符 | 描述                                                         |
    | :--------- | :----------------------------------------------------------- |
    | Out        | 将参数声明为通过引用传递，从而允许该函数对其进行修改。       |
    | Optional   | 使用optional关键字，可以将某些函数参数设置为可选，以方便调用者。调用者未指定的可选参数的值取决于函数。例如，该`SpawnActor`函数采用可选的位置和旋转方式，默认为产卵Actor根组件的位置和旋转方式。可选参数的默认值可以通过添加来指定`= [value]`。例如：`function myFunc(optional int x = -1)`。在大多数情况下，当没有值传递给可选参数时，将使用变量类型的默认值或零（0，false，“”，none）。 |

* 委托
  * **委托**可以以通用的类型安全的方式在C ++对象上调用成员函数。可以将委托动态绑定到任意对象的成员函数，即使将来调用者不知道对象的类型，也可以在将来对其进行调用。代表可以安全复制。您也可以按值传递它们，但是不建议这样做，因为此过程将在堆上分配内存；尽可能通过引用传递委托。引擎支持三种类型的委托：
    - 单委托
    - [多播委托](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates/Multicast/index.html),[Events](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates/Events/index.html)
    - [动态](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates/Dynamic/index.html)

* [计时器](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Timers/index.html)