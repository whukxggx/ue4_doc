# 代码生成

## UnrealHeaderTool和UnrealBuildTool

### 两者作用

UBT通过扫描头文件，记录所有包含反射类型的modules，当其中有头文件改变时，就会用UHT更新反射数据。UHT解析头文件，扫描标记，生成用于支持反射的C++代码。

## UCLASS实例代码

```c++
// Copyright Epic Games, Inc. All Rights Reserved.
//ReflectionStudyGameMode.h
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameModeBase.h"
#include "ReflectionStudyGameMode.generated.h"

UCLASS(minimalapi)
class AReflectionStudyGameMode : public AGameModeBase
{
	GENERATED_BODY()

public:
	AReflectionStudyGameMode();
protected:
	UPROPERTY(BlueprintReadWrite, Category = "AReflectionStudyGameMode")
		float Score;
	UFUNCTION(BlueprintCallable, Category = "AReflectionStudyGameMode")
		void CallableFuncTest();
	UFUNCTION(BlueprintNativeEvent, Category = "AReflectionStudyGameMode")
		void NativeFuncTest();
	UFUNCTION(BlueprintImplementableEvent, Category = "AReflectionStudyGameMode")
		void ImplementableFuncTest();
};




```

```c++
// Copyright Epic Games, Inc. All Rights Reserved.
//ReflectionStudyGameMode.cpp

#include "ReflectionStudyGameMode.h"
#include "ReflectionStudyCharacter.h"
#include "UObject/ConstructorHelpers.h"

AReflectionStudyGameMode::AReflectionStudyGameMode()
{
	// set default pawn class to our Blueprinted character
	static ConstructorHelpers::FClassFinder<APawn> PlayerPawnBPClass(TEXT("/Game/ThirdPersonCPP/Blueprints/ThirdPersonCharacter"));
	if (PlayerPawnBPClass.Class != NULL)
	{
		DefaultPawnClass = PlayerPawnBPClass.Class;
	}
}

void AReflectionStudyGameMode::CallableFuncTest()
{

}
void AReflectionStudyGameMode::NativeFuncTest_Implementation()
{

}
```

```c++
// Copyright Epic Games, Inc. All Rights Reserved.
/*===========================================================================
	Generated code exported from UnrealHeaderTool.
	DO NOT modify this manually! Edit the corresponding .h files instead!
===========================================================================*/
//ReflectionStudyGameMode.generated.h

#include "UObject/ObjectMacros.h"
#include "UObject/ScriptMacros.h"

PRAGMA_DISABLE_DEPRECATION_WARNINGS
#ifdef REFLECTIONSTUDY_ReflectionStudyGameMode_generated_h
#error "ReflectionStudyGameMode.generated.h already included, missing '#pragma once' in ReflectionStudyGameMode.h"
#endif
#define REFLECTIONSTUDY_ReflectionStudyGameMode_generated_h

#define ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_SPARSE_DATA
#define ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_RPC_WRAPPERS \
	virtual void NativeFuncTest_Implementation(); \
 \
	DECLARE_FUNCTION(execNativeFuncTest); \
	DECLARE_FUNCTION(execCallableFuncTest);


#define ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_RPC_WRAPPERS_NO_PURE_DECLS \
	virtual void NativeFuncTest_Implementation(); \
 \
	DECLARE_FUNCTION(execNativeFuncTest); \
	DECLARE_FUNCTION(execCallableFuncTest);


#define ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_EVENT_PARMS
#define ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_CALLBACK_WRAPPERS
#define ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_INCLASS_NO_PURE_DECLS \
private: \
	static void StaticRegisterNativesAReflectionStudyGameMode(); \
	friend struct Z_Construct_UClass_AReflectionStudyGameMode_Statics; \
public: \
	DECLARE_CLASS(AReflectionStudyGameMode, AGameModeBase, COMPILED_IN_FLAGS(0 | CLASS_Transient | CLASS_Config), CASTCLASS_None, TEXT("/Script/ReflectionStudy"), REFLECTIONSTUDY_API) \
	DECLARE_SERIALIZER(AReflectionStudyGameMode)


#define ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_INCLASS \
private: \
	static void StaticRegisterNativesAReflectionStudyGameMode(); \
	friend struct Z_Construct_UClass_AReflectionStudyGameMode_Statics; \
public: \
	DECLARE_CLASS(AReflectionStudyGameMode, AGameModeBase, COMPILED_IN_FLAGS(0 | CLASS_Transient | CLASS_Config), CASTCLASS_None, TEXT("/Script/ReflectionStudy"), REFLECTIONSTUDY_API) \
	DECLARE_SERIALIZER(AReflectionStudyGameMode)


#define ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_STANDARD_CONSTRUCTORS \
	/** Standard constructor, called after all reflected properties have been initialized */ \
	REFLECTIONSTUDY_API AReflectionStudyGameMode(const FObjectInitializer& ObjectInitializer); \
	DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(AReflectionStudyGameMode) \
	DECLARE_VTABLE_PTR_HELPER_CTOR(REFLECTIONSTUDY_API, AReflectionStudyGameMode); \
DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(AReflectionStudyGameMode); \
private: \
	/** Private move- and copy-constructors, should never be used */ \
	REFLECTIONSTUDY_API AReflectionStudyGameMode(AReflectionStudyGameMode&&); \
	REFLECTIONSTUDY_API AReflectionStudyGameMode(const AReflectionStudyGameMode&); \
public:


#define ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_ENHANCED_CONSTRUCTORS \
private: \
	/** Private move- and copy-constructors, should never be used */ \
	REFLECTIONSTUDY_API AReflectionStudyGameMode(AReflectionStudyGameMode&&); \
	REFLECTIONSTUDY_API AReflectionStudyGameMode(const AReflectionStudyGameMode&); \
public: \
	DECLARE_VTABLE_PTR_HELPER_CTOR(REFLECTIONSTUDY_API, AReflectionStudyGameMode); \
DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(AReflectionStudyGameMode); \
	DEFINE_DEFAULT_CONSTRUCTOR_CALL(AReflectionStudyGameMode)


#define ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_PRIVATE_PROPERTY_OFFSET \
	FORCEINLINE static uint32 __PPO__Score() { return STRUCT_OFFSET(AReflectionStudyGameMode, Score); }


#define ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_9_PROLOG \
	ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_EVENT_PARMS


#define ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_GENERATED_BODY_LEGACY \
PRAGMA_DISABLE_DEPRECATION_WARNINGS \
public: \
	ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_PRIVATE_PROPERTY_OFFSET \
	ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_SPARSE_DATA \
	ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_RPC_WRAPPERS \
	ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_CALLBACK_WRAPPERS \
	ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_INCLASS \
	ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_STANDARD_CONSTRUCTORS \
public: \
PRAGMA_ENABLE_DEPRECATION_WARNINGS


#define ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_GENERATED_BODY \
PRAGMA_DISABLE_DEPRECATION_WARNINGS \
public: \
	ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_PRIVATE_PROPERTY_OFFSET \
	ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_SPARSE_DATA \
	ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_RPC_WRAPPERS_NO_PURE_DECLS \
	ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_CALLBACK_WRAPPERS \
	ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_INCLASS_NO_PURE_DECLS \
	ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_ENHANCED_CONSTRUCTORS \
private: \
PRAGMA_ENABLE_DEPRECATION_WARNINGS


template<> REFLECTIONSTUDY_API UClass* StaticClass<class AReflectionStudyGameMode>();

#undef CURRENT_FILE_ID
#define CURRENT_FILE_ID ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h


PRAGMA_ENABLE_DEPRECATION_WARNINGS

```

```c++
// Copyright Epic Games, Inc. All Rights Reserved.
/*===========================================================================
	Generated code exported from UnrealHeaderTool.
	DO NOT modify this manually! Edit the corresponding .h files instead!
===========================================================================*/
//ReflectionStudyGameMode.gen.cpp

#include "UObject/GeneratedCppIncludes.h"
#include "ReflectionStudy/ReflectionStudyGameMode.h"
#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable : 4883)
#endif
PRAGMA_DISABLE_DEPRECATION_WARNINGS
void EmptyLinkFunctionForGeneratedCodeReflectionStudyGameMode() {}
// Cross Module References
	REFLECTIONSTUDY_API UClass* Z_Construct_UClass_AReflectionStudyGameMode_NoRegister();
	REFLECTIONSTUDY_API UClass* Z_Construct_UClass_AReflectionStudyGameMode();
	ENGINE_API UClass* Z_Construct_UClass_AGameModeBase();
	UPackage* Z_Construct_UPackage__Script_ReflectionStudy();
// End Cross Module References
	DEFINE_FUNCTION(AReflectionStudyGameMode::execNativeFuncTest)
	{
		P_FINISH;
		P_NATIVE_BEGIN;
		P_THIS->NativeFuncTest_Implementation();
		P_NATIVE_END;
	}
	DEFINE_FUNCTION(AReflectionStudyGameMode::execCallableFuncTest)
	{
		P_FINISH;
		P_NATIVE_BEGIN;
		P_THIS->CallableFuncTest();
		P_NATIVE_END;
	}
	static FName NAME_AReflectionStudyGameMode_ImplementableFuncTest = FName(TEXT("ImplementableFuncTest"));
	void AReflectionStudyGameMode::ImplementableFuncTest()
	{
		ProcessEvent(FindFunctionChecked(NAME_AReflectionStudyGameMode_ImplementableFuncTest),NULL);
	}
	static FName NAME_AReflectionStudyGameMode_NativeFuncTest = FName(TEXT("NativeFuncTest"));
	void AReflectionStudyGameMode::NativeFuncTest()
	{
		ProcessEvent(FindFunctionChecked(NAME_AReflectionStudyGameMode_NativeFuncTest),NULL);
	}
	void AReflectionStudyGameMode::StaticRegisterNativesAReflectionStudyGameMode()
	{
		UClass* Class = AReflectionStudyGameMode::StaticClass();
		static const FNameNativePtrPair Funcs[] = {
			{ "CallableFuncTest", &AReflectionStudyGameMode::execCallableFuncTest },
			{ "NativeFuncTest", &AReflectionStudyGameMode::execNativeFuncTest },
		};
		FNativeFunctionRegistrar::RegisterFunctions(Class, Funcs, UE_ARRAY_COUNT(Funcs));
	}
	struct Z_Construct_UFunction_AReflectionStudyGameMode_CallableFuncTest_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AReflectionStudyGameMode_CallableFuncTest_Statics::Function_MetaDataParams[] = {
		{ "Category", "AReflectionStudyGameMode" },
		{ "ModuleRelativePath", "ReflectionStudyGameMode.h" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AReflectionStudyGameMode_CallableFuncTest_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AReflectionStudyGameMode, nullptr, "CallableFuncTest", nullptr, nullptr, 0, nullptr, 0, RF_Public|RF_Transient|RF_MarkAsNative, (EFunctionFlags)0x04080401, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AReflectionStudyGameMode_CallableFuncTest_Statics::Function_MetaDataParams, UE_ARRAY_COUNT(Z_Construct_UFunction_AReflectionStudyGameMode_CallableFuncTest_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AReflectionStudyGameMode_CallableFuncTest()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AReflectionStudyGameMode_CallableFuncTest_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AReflectionStudyGameMode_ImplementableFuncTest_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AReflectionStudyGameMode_ImplementableFuncTest_Statics::Function_MetaDataParams[] = {
		{ "Category", "AReflectionStudyGameMode" },
		{ "ModuleRelativePath", "ReflectionStudyGameMode.h" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AReflectionStudyGameMode_ImplementableFuncTest_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AReflectionStudyGameMode, nullptr, "ImplementableFuncTest", nullptr, nullptr, 0, nullptr, 0, RF_Public|RF_Transient|RF_MarkAsNative, (EFunctionFlags)0x08080800, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AReflectionStudyGameMode_ImplementableFuncTest_Statics::Function_MetaDataParams, UE_ARRAY_COUNT(Z_Construct_UFunction_AReflectionStudyGameMode_ImplementableFuncTest_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AReflectionStudyGameMode_ImplementableFuncTest()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AReflectionStudyGameMode_ImplementableFuncTest_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	struct Z_Construct_UFunction_AReflectionStudyGameMode_NativeFuncTest_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];
#endif
		static const UE4CodeGen_Private::FFunctionParams FuncParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AReflectionStudyGameMode_NativeFuncTest_Statics::Function_MetaDataParams[] = {
		{ "Category", "AReflectionStudyGameMode" },
		{ "ModuleRelativePath", "ReflectionStudyGameMode.h" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AReflectionStudyGameMode_NativeFuncTest_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AReflectionStudyGameMode, nullptr, "NativeFuncTest", nullptr, nullptr, 0, nullptr, 0, RF_Public|RF_Transient|RF_MarkAsNative, (EFunctionFlags)0x08080C00, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AReflectionStudyGameMode_NativeFuncTest_Statics::Function_MetaDataParams, UE_ARRAY_COUNT(Z_Construct_UFunction_AReflectionStudyGameMode_NativeFuncTest_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AReflectionStudyGameMode_NativeFuncTest()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AReflectionStudyGameMode_NativeFuncTest_Statics::FuncParams);
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AReflectionStudyGameMode_NoRegister()
	{
		return AReflectionStudyGameMode::StaticClass();
	}
	struct Z_Construct_UClass_AReflectionStudyGameMode_Statics
	{
		static UObject* (*const DependentSingletons[])();
		static const FClassFunctionLinkInfo FuncInfo[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Class_MetaDataParams[];
#endif
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Score_MetaData[];
#endif
		static const UE4CodeGen_Private::FFloatPropertyParams NewProp_Score;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
		static const FCppClassTypeInfoStatic StaticCppClassTypeInfo;
		static const UE4CodeGen_Private::FClassParams ClassParams;
	};
	UObject* (*const Z_Construct_UClass_AReflectionStudyGameMode_Statics::DependentSingletons[])() = {
		(UObject* (*)())Z_Construct_UClass_AGameModeBase,
		(UObject* (*)())Z_Construct_UPackage__Script_ReflectionStudy,
	};
	const FClassFunctionLinkInfo Z_Construct_UClass_AReflectionStudyGameMode_Statics::FuncInfo[] = {
		{ &Z_Construct_UFunction_AReflectionStudyGameMode_CallableFuncTest, "CallableFuncTest" }, // 193299223
		{ &Z_Construct_UFunction_AReflectionStudyGameMode_ImplementableFuncTest, "ImplementableFuncTest" }, // 3403616330
		{ &Z_Construct_UFunction_AReflectionStudyGameMode_NativeFuncTest, "NativeFuncTest" }, // 404397242
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_AReflectionStudyGameMode_Statics::Class_MetaDataParams[] = {
		{ "HideCategories", "Info Rendering MovementReplication Replication Actor Input Movement Collision Rendering Utilities|Transformation" },
		{ "IncludePath", "ReflectionStudyGameMode.h" },
		{ "ModuleRelativePath", "ReflectionStudyGameMode.h" },
		{ "ShowCategories", "Input|MouseInput Input|TouchInput" },
	};
#endif
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_AReflectionStudyGameMode_Statics::NewProp_Score_MetaData[] = {
		{ "Category", "AReflectionStudyGameMode" },
		{ "ModuleRelativePath", "ReflectionStudyGameMode.h" },
	};
#endif
	const UE4CodeGen_Private::FFloatPropertyParams Z_Construct_UClass_AReflectionStudyGameMode_Statics::NewProp_Score = { "Score", nullptr, (EPropertyFlags)0x0020080000000004, UE4CodeGen_Private::EPropertyGenFlags::Float, RF_Public|RF_Transient|RF_MarkAsNative, 1, STRUCT_OFFSET(AReflectionStudyGameMode, Score), METADATA_PARAMS(Z_Construct_UClass_AReflectionStudyGameMode_Statics::NewProp_Score_MetaData, UE_ARRAY_COUNT(Z_Construct_UClass_AReflectionStudyGameMode_Statics::NewProp_Score_MetaData)) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UClass_AReflectionStudyGameMode_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UClass_AReflectionStudyGameMode_Statics::NewProp_Score,
	};
	const FCppClassTypeInfoStatic Z_Construct_UClass_AReflectionStudyGameMode_Statics::StaticCppClassTypeInfo = {
		TCppClassTypeTraits<AReflectionStudyGameMode>::IsAbstract,
	};
	const UE4CodeGen_Private::FClassParams Z_Construct_UClass_AReflectionStudyGameMode_Statics::ClassParams = {
		&AReflectionStudyGameMode::StaticClass,
		"Game",
		&StaticCppClassTypeInfo,
		DependentSingletons,
		FuncInfo,
		Z_Construct_UClass_AReflectionStudyGameMode_Statics::PropPointers,
		nullptr,
		UE_ARRAY_COUNT(DependentSingletons),
		UE_ARRAY_COUNT(FuncInfo),
		UE_ARRAY_COUNT(Z_Construct_UClass_AReflectionStudyGameMode_Statics::PropPointers),
		0,
		0x008802ACu,
		METADATA_PARAMS(Z_Construct_UClass_AReflectionStudyGameMode_Statics::Class_MetaDataParams, UE_ARRAY_COUNT(Z_Construct_UClass_AReflectionStudyGameMode_Statics::Class_MetaDataParams))
	};
	UClass* Z_Construct_UClass_AReflectionStudyGameMode()
	{
		static UClass* OuterClass = nullptr;
		if (!OuterClass)
		{
			UE4CodeGen_Private::ConstructUClass(OuterClass, Z_Construct_UClass_AReflectionStudyGameMode_Statics::ClassParams);
		}
		return OuterClass;
	}
	IMPLEMENT_CLASS(AReflectionStudyGameMode, 2351057212);
	template<> REFLECTIONSTUDY_API UClass* StaticClass<AReflectionStudyGameMode>()
	{
		return AReflectionStudyGameMode::StaticClass();
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AReflectionStudyGameMode(Z_Construct_UClass_AReflectionStudyGameMode, &AReflectionStudyGameMode::StaticClass, TEXT("/Script/ReflectionStudy"), TEXT("AReflectionStudyGameMode"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AReflectionStudyGameMode);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
#ifdef _MSC_VER
#pragma warning (pop)
#endif

```

代码分析:

首先看下Mode头文件的GENERATED_BODY的宏定义：

```c++
#define GENERATED_BODY(...) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_GENERATED_BODY);
#define BODY_MACRO_COMBINE(A,B,C,D) BODY_MACRO_COMBINE_INNER(A,B,C,D)
#define BODY_MACRO_COMBINE_INNER(A,B,C,D) A##B##C##D
```

即，生成CURRENT_FILE_ID和\__LINE__以及_GENERATED_BODY连接的一个名字。可以在反射头文件中看到，定义了

```c++
#define CURRENT_FILE_ID ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h
```

以及GENERATED_BODY最终的定义:

```c++
#define ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_GENERATED_BODY \
PRAGMA_DISABLE_DEPRECATION_WARNINGS \
public: \
	ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_PRIVATE_PROPERTY_OFFSET \
	ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_SPARSE_DATA \
	ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_RPC_WRAPPERS_NO_PURE_DECLS \
	ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_CALLBACK_WRAPPERS \
	ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_INCLASS_NO_PURE_DECLS \
	ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_ENHANCED_CONSTRUCTORS \
private: \
PRAGMA_ENABLE_DEPRECATION_WARNINGS
```

里面包含了六个宏，一个个看:

```c++
#define ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_PRIVATE_PROPERTY_OFFSET \
	FORCEINLINE static uint32 __PPO__Score() { return STRUCT_OFFSET(AReflectionStudyGameMode, Score); }
```

此函数返回定义的Score成员的offset值。

```c++
#define ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_SPARSE_DATA
```

此宏为空。

```c++
#define ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_RPC_WRAPPERS_NO_PURE_DECLS \
	virtual void NativeFuncTest_Implementation(); \
 \
	DECLARE_FUNCTION(execNativeFuncTest); \
	DECLARE_FUNCTION(execCallableFuncTest);
```

此宏定义声明了两个函数，可以看到`DECLARE_FUNCTION`的宏定义如下：

```c++
// This macro is used to declare a thunk function in autogenerated boilerplate code
#define DECLARE_FUNCTION(func) static void func( UObject* Context, FFrame& Stack, RESULT_DECL )
```

即，声明一个thunk函数。注意声明的两个函数前都有exec前缀，这是ue4的约定，这两个函数是给蓝图调用的。

在对应的cpp文件中查看函数定义：

```c++
	DEFINE_FUNCTION(AReflectionStudyGameMode::execNativeFuncTest)
	{
		P_FINISH;
		P_NATIVE_BEGIN;
		P_THIS->NativeFuncTest_Implementation();
		P_NATIVE_END;
	}
	DEFINE_FUNCTION(AReflectionStudyGameMode::execCallableFuncTest)
	{
		P_FINISH;
		P_NATIVE_BEGIN;
		P_THIS->CallableFuncTest();
		P_NATIVE_END;
	}

/*
// This macro is used to define a thunk function in autogenerated boilerplate code
#define DEFINE_FUNCTION(func) void func( UObject* Context, FFrame& Stack, RESULT_DECL )
*/
```

可以看到定义了一个thunk函数，thunk函数是一个包装，它的核心任务是处理虚拟机的Stack，然后调用我们使用c++实现的函数。

将第一个exec函数展开：

```c++
void func( UObject* Context, FFrame& Stack, RESULT_DECL )
{
    Stack.Code += !!Stack.Code;/* increment the code ptr unless it is null */
    {
        FBlueprintEventTimer::FScopedNativeTimer ScopedNativeCallTimer;//蓝图计时统计
        this->NativeFuncTest_Implementation();
    }
}
```



```c++
#define ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_CALLBACK_WRAPPERS
```

此宏为空。

```c++
#define ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_INCLASS_NO_PURE_DECLS \
private: \
	static void StaticRegisterNativesAReflectionStudyGameMode(); \
	friend struct Z_Construct_UClass_AReflectionStudyGameMode_Statics; \
public: \
	DECLARE_CLASS(AReflectionStudyGameMode, AGameModeBase, COMPILED_IN_FLAGS(0 | CLASS_Transient | CLASS_Config), CASTCLASS_None, TEXT("/Script/ReflectionStudy"), REFLECTIONSTUDY_API) \
	DECLARE_SERIALIZER(AReflectionStudyGameMode)


#define ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_INCLASS \
private: \
	static void StaticRegisterNativesAReflectionStudyGameMode(); \
	friend struct Z_Construct_UClass_AReflectionStudyGameMode_Statics; \
public: \
	DECLARE_CLASS(AReflectionStudyGameMode, AGameModeBase, COMPILED_IN_FLAGS(0 | CLASS_Transient | CLASS_Config), CASTCLASS_None, TEXT("/Script/ReflectionStudy"), REFLECTIONSTUDY_API) \
	DECLARE_SERIALIZER(AReflectionStudyGameMode)
```

此宏东西较多。

先看第一个函数`StaticRegisterNativesAReflectionStudyGameMode`：

```c++
	void AReflectionStudyGameMode::StaticRegisterNativesAReflectionStudyGameMode()
	{
		UClass* Class = AReflectionStudyGameMode::StaticClass();
		static const FNameNativePtrPair Funcs[] = {
			{ "CallableFuncTest", &AReflectionStudyGameMode::execCallableFuncTest },
			{ "NativeFuncTest", &AReflectionStudyGameMode::execNativeFuncTest },
		};
		FNativeFunctionRegistrar::RegisterFunctions(Class, Funcs, UE_ARRAY_COUNT(Funcs));
	}
```

可以看到此函数是将之前声明的两个函数进行注册，即注册c++原生函数，暴露给虚拟机使用的。

之后是一个友元结构体，里面定义了一系列静态常量，如下：

```c++
	struct Z_Construct_UClass_AReflectionStudyGameMode_Statics
	{
		static UObject* (*const DependentSingletons[])();
		static const FClassFunctionLinkInfo FuncInfo[];
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Class_MetaDataParams[];
#endif
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Score_MetaData[];
#endif
		static const UE4CodeGen_Private::FFloatPropertyParams NewProp_Score;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
		static const FCppClassTypeInfoStatic StaticCppClassTypeInfo;
		static const UE4CodeGen_Private::FClassParams ClassParams;
	};
```

主要作用是记录类的构造信息。

之后是`DECLARE_CLASS`，

```c++
#define DECLARE_CLASS( TClass, TSuperClass, TStaticFlags, TStaticCastFlags, TPackage, TRequiredAPI  ) \
private: \
    TClass& operator=(TClass&&);   \
    TClass& operator=(const TClass&);   \
	TRequiredAPI static UClass* GetPrivateStaticClass(); \
public: \
	/** Bitwise union of #EClassFlags pertaining to this class.*/ \
	enum {StaticClassFlags=TStaticFlags}; \
	/** Typedef for the base class ({{ typedef-type }}) */ \
	typedef TSuperClass Super;\
	/** Typedef for {{ typedef-type }}. */ \
	typedef TClass ThisClass;\
	/** Returns a UClass object representing this class at runtime */ \
	inline static UClass* StaticClass() \
	{ \
		return GetPrivateStaticClass(); \
	} \
	/** Returns the package this class belongs in */ \
	inline static const TCHAR* StaticPackage() \
	{ \
		return TPackage; \
	} \
	/** Returns the static cast flags for this class */ \
	inline static EClassCastFlags StaticClassCastFlags() \
	{ \
		return TStaticCastFlags; \
	} \
	/** For internal use only; use StaticConstructObject() to create new objects. */ \
	inline void* operator new(const size_t InSize, EInternal InInternalOnly, UObject* InOuter = (UObject*)GetTransientPackage(), FName InName = NAME_None, EObjectFlags InSetFlags = RF_NoFlags) \
	{ \
		return StaticAllocateObject(StaticClass(), InOuter, InName, InSetFlags); \
	} \
	/** For internal use only; use StaticConstructObject() to create new objects. */ \
	inline void* operator new( const size_t InSize, EInternal* InMem ) \
	{ \
		return (void*)InMem; \
	}
```

先看下此函数各个参数含义：

TCLASS : 类名

TSuperClass: 基类名

TStaticFlags: 类的属性标记

TStaticCastFlags: 指定了该类可以转换为哪些类。这里为`CASTCLASS_None`表示不能转换为一些默认的类。

TPackage: 类所处的包名，此处为`/Script/ReflectionStudy`

TRequiredAPI:用来DLL导入导出的标记。

此宏主要声明了一些常用函数如StaticClass。此函数调用的GetPrivateStaticClass在对应的cpp文件中实现，内容如下：

`IMPLEMENT_CLASS(AReflectionStudyGameMode, 2351057212);`

此宏的内容如下：

```c++
#define IMPLEMENT_CLASS(TClass, TClassCrc) \
	static TClassCompiledInDefer<TClass> AutoInitialize##TClass(TEXT(#TClass), sizeof(TClass), TClassCrc); \
	UClass* TClass::GetPrivateStaticClass() \
	{ \
		static UClass* PrivateStaticClass = NULL; \
		if (!PrivateStaticClass) \
		{ \
			/* this could be handled with templates, but we want it external to avoid code bloat */ \
			GetPrivateStaticClassBody( \
				StaticPackage(), \
				(TCHAR*)TEXT(#TClass) + 1 + ((StaticClassFlags & CLASS_Deprecated) ? 11 : 0), \
				PrivateStaticClass, \
				StaticRegisterNatives##TClass, \
				sizeof(TClass), \
				alignof(TClass), \
				(EClassFlags)TClass::StaticClassFlags, \
				TClass::StaticClassCastFlags(), \
				TClass::StaticConfigName(), \
				(UClass::ClassConstructorType)InternalConstructor<TClass>, \
				(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>, \
				&TClass::AddReferencedObjects, \
				&TClass::Super::StaticClass, \
				&TClass::WithinClass::StaticClass \
			); \
		} \
		return PrivateStaticClass; \
	}
```

可以看到其不仅定义了一个函数，还定义了一个静态变量，用于在程序启动时注册UClass。

在GetPrivateStaticClassBody函数内部进行具体的构造。

而`DECLARE_SERIALIZER(AReflectionStudyGameMode)`则是定义了相关序列化函数的内容：

```c++
#define DECLARE_SERIALIZER( TClass ) \
	friend FArchive &operator<<( FArchive& Ar, TClass*& Res ) \
	{ \
		return Ar << (UObject*&)Res; \
	} \
	friend void operator<<(FStructuredArchive::FSlot InSlot, TClass*& Res) \
	{ \
		InSlot << (UObject*&)Res; \
	}
```

最后一个宏：

```c++
#define ReflectionStudy_Source_ReflectionStudy_ReflectionStudyGameMode_h_12_ENHANCED_CONSTRUCTORS \
private: \
	/** Private move- and copy-constructors, should never be used */ \
	REFLECTIONSTUDY_API AReflectionStudyGameMode(AReflectionStudyGameMode&&); \
	REFLECTIONSTUDY_API AReflectionStudyGameMode(const AReflectionStudyGameMode&); \
public: \
	DECLARE_VTABLE_PTR_HELPER_CTOR(REFLECTIONSTUDY_API, AReflectionStudyGameMode); \
DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(AReflectionStudyGameMode); \
	DEFINE_DEFAULT_CONSTRUCTOR_CALL(AReflectionStudyGameMode)
```

private的内容不多说，隐藏移动构造函数和复制构造函数。

```c++
	DECLARE_VTABLE_PTR_HELPER_CTOR(REFLECTIONSTUDY_API, AReflectionStudyGameMode); \
DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(AReflectionStudyGameMode); \
```

这两个宏是热加载相关。

```c++
DEFINE_DEFAULT_CONSTRUCTOR_CALL(AReflectionStudyGameMode)
```

此宏定义了一个默认构造函数：

```c++
#define DEFINE_DEFAULT_CONSTRUCTOR_CALL(TClass) \
	static void __DefaultConstructor(const FObjectInitializer& X) { new((EInternal*)X.GetObj())TClass; }
```

同时，可以看到反射cpp文件中，有原mode类中未实现的函数的实现：

```c++
	static FName NAME_AReflectionStudyGameMode_ImplementableFuncTest = FName(TEXT("ImplementableFuncTest"));
	void AReflectionStudyGameMode::ImplementableFuncTest()
	{
		ProcessEvent(FindFunctionChecked(NAME_AReflectionStudyGameMode_ImplementableFuncTest),NULL);
	}
	static FName NAME_AReflectionStudyGameMode_NativeFuncTest = FName(TEXT("NativeFuncTest"));
	void AReflectionStudyGameMode::NativeFuncTest()
	{
		ProcessEvent(FindFunctionChecked(NAME_AReflectionStudyGameMode_NativeFuncTest),NULL);
	}
```

可以看到转调用了ProcessEvent函数进行实现。

之后可以看到

```c++
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_AReflectionStudyGameMode_CallableFuncTest_Statics::Function_MetaDataParams[] = {
		{ "Category", "AReflectionStudyGameMode" },
		{ "ModuleRelativePath", "ReflectionStudyGameMode.h" },
	};
#endif
	const UE4CodeGen_Private::FFunctionParams Z_Construct_UFunction_AReflectionStudyGameMode_CallableFuncTest_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_AReflectionStudyGameMode, nullptr, "CallableFuncTest", nullptr, nullptr, 0, nullptr, 0, RF_Public|RF_Transient|RF_MarkAsNative, (EFunctionFlags)0x04080401, 0, 0, METADATA_PARAMS(Z_Construct_UFunction_AReflectionStudyGameMode_CallableFuncTest_Statics::Function_MetaDataParams, UE_ARRAY_COUNT(Z_Construct_UFunction_AReflectionStudyGameMode_CallableFuncTest_Statics::Function_MetaDataParams)) };
	UFunction* Z_Construct_UFunction_AReflectionStudyGameMode_CallableFuncTest()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, Z_Construct_UFunction_AReflectionStudyGameMode_CallableFuncTest_Statics::FuncParams);
		}
		return ReturnFunction;
	}
```

这个是关于`CallableFuncTest`，其他几个于此相似，这几个construct最终被注册到上面所说的`Z_Construct_UClass_AReflectionStudyGameMode_Statics`的FuncInfo中，

```c++
	const FClassFunctionLinkInfo Z_Construct_UClass_AReflectionStudyGameMode_Statics::FuncInfo[] = {
		{ &Z_Construct_UFunction_AReflectionStudyGameMode_CallableFuncTest, "CallableFuncTest" }, // 193299223
		{ &Z_Construct_UFunction_AReflectionStudyGameMode_ImplementableFuncTest, "ImplementableFuncTest" }, // 3403616330
		{ &Z_Construct_UFunction_AReflectionStudyGameMode_NativeFuncTest, "NativeFuncTest" }, // 404397242
	};
```

最终此`Z_Construct_UClass_AReflectionStudyGameMode_Statics`结构体在

```c++
	UClass* Z_Construct_UClass_AReflectionStudyGameMode()
	{
		static UClass* OuterClass = nullptr;
		if (!OuterClass)
		{
			UE4CodeGen_Private::ConstructUClass(OuterClass, Z_Construct_UClass_AReflectionStudyGameMode_Statics::ClassParams);
		}
		return OuterClass;
	}
```

通过`ClassParams`进行构造。`ClassParams`中包含了function和属性等类的信息，最终通过一个静态数据进行注册：

```c++
static FCompiledInDefer Z_CompiledInDefer_UClass_AReflectionStudyGameMode(Z_Construct_UClass_AReflectionStudyGameMode, &AReflectionStudyGameMode::StaticClass, TEXT("/Script/ReflectionStudy"), TEXT("AReflectionStudyGameMode"), false, nullptr, nullptr, nullptr);
```

这样就注册了UFUNCTION和UPROPERTY对象。

## USTRUCT实例代码

结构体代码如下：

```c++
USTRUCT(Blueprintable)
struct FReflectionStruct {
	GENERATED_USTRUCT_BODY()

	UPROPERTY(BlueprintReadWrite)
		float ReflectionValue;
};
```

对应的反射代码头文件:

```c++
#include "UObject/ObjectMacros.h"
#include "UObject/ScriptMacros.h"

PRAGMA_DISABLE_DEPRECATION_WARNINGS
#ifdef REFLECTIONSTUDY_ReflectionStructTest_generated_h
#error "ReflectionStructTest.generated.h already included, missing '#pragma once' in ReflectionStructTest.h"
#endif
#define REFLECTIONSTUDY_ReflectionStructTest_generated_h

#define ReflectionStudy_Source_ReflectionStudy_Public_ReflectionStructTest_h_20_GENERATED_BODY \
	friend struct Z_Construct_UScriptStruct_FReflectionStruct_Statics; \
	REFLECTIONSTUDY_API static class UScriptStruct* StaticStruct();


template<> REFLECTIONSTUDY_API UScriptStruct* StaticStruct<struct FReflectionStruct>();

#undef CURRENT_FILE_ID
#define CURRENT_FILE_ID ReflectionStudy_Source_ReflectionStudy_Public_ReflectionStructTest_h


PRAGMA_ENABLE_DEPRECATION_WARNINGS
```

对应cpp文件:

```c++
#include "UObject/GeneratedCppIncludes.h"
#include "ReflectionStudy/Public/ReflectionStructTest.h"
#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable : 4883)
#endif
PRAGMA_DISABLE_DEPRECATION_WARNINGS
void EmptyLinkFunctionForGeneratedCodeReflectionStructTest() {}
// Cross Module References
	REFLECTIONSTUDY_API UScriptStruct* Z_Construct_UScriptStruct_FReflectionStruct();
	UPackage* Z_Construct_UPackage__Script_ReflectionStudy();
// End Cross Module References
class UScriptStruct* FReflectionStruct::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern REFLECTIONSTUDY_API uint32 Get_Z_Construct_UScriptStruct_FReflectionStruct_Hash();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FReflectionStruct, Z_Construct_UPackage__Script_ReflectionStudy(), TEXT("ReflectionStruct"), sizeof(FReflectionStruct), Get_Z_Construct_UScriptStruct_FReflectionStruct_Hash());
	}
	return Singleton;
}
template<> REFLECTIONSTUDY_API UScriptStruct* StaticStruct<FReflectionStruct>()
{
	return FReflectionStruct::StaticStruct();
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FReflectionStruct(FReflectionStruct::StaticStruct, TEXT("/Script/ReflectionStudy"), TEXT("ReflectionStruct"), false, nullptr, nullptr);
static struct FScriptStruct_ReflectionStudy_StaticRegisterNativesFReflectionStruct
{
	FScriptStruct_ReflectionStudy_StaticRegisterNativesFReflectionStruct()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("ReflectionStruct")),new UScriptStruct::TCppStructOps<FReflectionStruct>);
	}
} ScriptStruct_ReflectionStudy_StaticRegisterNativesFReflectionStruct;
	struct Z_Construct_UScriptStruct_FReflectionStruct_Statics
	{
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[];
#endif
		static void* NewStructOps();
#if WITH_METADATA
		static const UE4CodeGen_Private::FMetaDataPairParam NewProp_ReflectionValue_MetaData[];
#endif
		static const UE4CodeGen_Private::FFloatPropertyParams NewProp_ReflectionValue;
		static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[];
		static const UE4CodeGen_Private::FStructParams ReturnStructParams;
	};
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UScriptStruct_FReflectionStruct_Statics::Struct_MetaDataParams[] = {
		{ "BlueprintType", "true" },
		{ "IsBlueprintBase", "true" },
		{ "ModuleRelativePath", "Public/ReflectionStructTest.h" },
	};
#endif
	void* Z_Construct_UScriptStruct_FReflectionStruct_Statics::NewStructOps()
	{
		return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FReflectionStruct>();
	}
#if WITH_METADATA
	const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UScriptStruct_FReflectionStruct_Statics::NewProp_ReflectionValue_MetaData[] = {
		{ "Category", "ReflectionStruct" },
		{ "ModuleRelativePath", "Public/ReflectionStructTest.h" },
	};
#endif
	const UE4CodeGen_Private::FFloatPropertyParams Z_Construct_UScriptStruct_FReflectionStruct_Statics::NewProp_ReflectionValue = { "ReflectionValue", nullptr, (EPropertyFlags)0x0010000000000004, UE4CodeGen_Private::EPropertyGenFlags::Float, RF_Public|RF_Transient|RF_MarkAsNative, 1, STRUCT_OFFSET(FReflectionStruct, ReflectionValue), METADATA_PARAMS(Z_Construct_UScriptStruct_FReflectionStruct_Statics::NewProp_ReflectionValue_MetaData, UE_ARRAY_COUNT(Z_Construct_UScriptStruct_FReflectionStruct_Statics::NewProp_ReflectionValue_MetaData)) };
	const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UScriptStruct_FReflectionStruct_Statics::PropPointers[] = {
		(const UE4CodeGen_Private::FPropertyParamsBase*)&Z_Construct_UScriptStruct_FReflectionStruct_Statics::NewProp_ReflectionValue,
	};
	const UE4CodeGen_Private::FStructParams Z_Construct_UScriptStruct_FReflectionStruct_Statics::ReturnStructParams = {
		(UObject* (*)())Z_Construct_UPackage__Script_ReflectionStudy,
		nullptr,
		&NewStructOps,
		"ReflectionStruct",
		sizeof(FReflectionStruct),
		alignof(FReflectionStruct),
		Z_Construct_UScriptStruct_FReflectionStruct_Statics::PropPointers,
		UE_ARRAY_COUNT(Z_Construct_UScriptStruct_FReflectionStruct_Statics::PropPointers),
		RF_Public|RF_Transient|RF_MarkAsNative,
		EStructFlags(0x00000001),
		METADATA_PARAMS(Z_Construct_UScriptStruct_FReflectionStruct_Statics::Struct_MetaDataParams, UE_ARRAY_COUNT(Z_Construct_UScriptStruct_FReflectionStruct_Statics::Struct_MetaDataParams))
	};
	UScriptStruct* Z_Construct_UScriptStruct_FReflectionStruct()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FReflectionStruct_Hash();
		UPackage* Outer = Z_Construct_UPackage__Script_ReflectionStudy();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("ReflectionStruct"), sizeof(FReflectionStruct), Get_Z_Construct_UScriptStruct_FReflectionStruct_Hash(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, Z_Construct_UScriptStruct_FReflectionStruct_Statics::ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FReflectionStruct_Hash() { return 2788294633U; }
PRAGMA_ENABLE_DEPRECATION_WARNINGS
#ifdef _MSC_VER
#pragma warning (pop)
#endif

```

内容较多，

GENERATED_USTRUCT_ BODY过程与class类似，不多说。

头文件中主要有一个友元结构体以及一个`StaticStruct()`函数获取反射结构体。

函数定义如下：

```c++
class UScriptStruct* FReflectionStruct::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern REFLECTIONSTUDY_API uint32 Get_Z_Construct_UScriptStruct_FReflectionStruct_Hash();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FReflectionStruct, Z_Construct_UPackage__Script_ReflectionStudy(), TEXT("ReflectionStruct"), sizeof(FReflectionStruct), Get_Z_Construct_UScriptStruct_FReflectionStruct_Hash());
	}
	return Singleton;
}
```

而友元结构体与Z_Construct_UScriptStruct_FReflectionStruct_Statics中的类似，包含结构体的一些属性和metadata等信息，对结构体的内容进行初始化后在`Z_Construct_UScriptStruct_FReflectionStruct`中进行具体的构建，此函数在StaticStruct中调用。

# 注册

## static自动注册模式

由于c++static对象会在main函数之前初始化，可以设计一种自动注册模式，大致如下：

```c++
struct StaticAutoRegister
{
	StaticAutoRegister()
	{
		Register(TClass::StaticClass());
	}
};
static StaticAutoRegister<MyClass> AutoRegister;
```

这样在main函数调用之前就会自动调用构造函数进行注册。

## UE中的信息收集

在UCLASS的反射代码中，可以看到有两个结构体用以反射：

```c++
template <typename TClass>
struct TClassCompiledInDefer : public FFieldCompiledInInfo
{
	TClassCompiledInDefer(const TCHAR* InName, SIZE_T InClassSize, uint32 InCrc)
	: FFieldCompiledInInfo(InClassSize, InCrc)
	{
		UClassCompiledInDefer(this, InName, InClassSize, InCrc);
	}
	virtual UClass* Register() const override
	{
        LLM_SCOPE(ELLMTag::UObject);
		return TClass::StaticClass();
	}
	virtual const TCHAR* ClassPackage() const override
	{
		return TClass::StaticPackage();
	}
};

struct FCompiledInDefer
{
	FCompiledInDefer(class UClass *(*InRegister)(), class UClass *(*InStaticClass)(), const TCHAR* PackageName, const TCHAR* Name, bool bDynamic, const TCHAR* DynamicPackageName = nullptr, const TCHAR* DynamicPathName = nullptr, void (*InInitSearchableValues)(TMap<FName, FName>&) = nullptr)
	{
		if (bDynamic)
		{
			GetConvertedDynamicPackageNameToTypeName().Add(FName(DynamicPackageName), FName(Name));
		}
		UObjectCompiledInDefer(InRegister, InStaticClass, Name, PackageName, bDynamic, DynamicPathName, InInitSearchableValues);
	}
};
```

其中第一个的静态对象是在`IMPLEMENT_CLASS`中进行声明的，

```c++
#define IMPLEMENT_CLASS(TClass, TClassCrc) \
	static TClassCompiledInDefer<TClass> AutoInitialize##TClass(TEXT(#TClass), sizeof(TClass), TClassCrc); \
```

第二个是在gen.cpp文件中进行声明的:

```c++
static FCompiledInDefer Z_CompiledInDefer_UClass_AReflectionStudyGameMode(Z_Construct_UClass_AReflectionStudyGameMode, &AReflectionStudyGameMode::StaticClass, TEXT("/Script/ReflectionStudy"), TEXT("AReflectionStudyGameMode"), false, nullptr, nullptr, nullptr);
```

查看`TClassCompiledInDefer`的声明，以及转调用的顺序：

```c++
template <typename TClass>
struct TClassCompiledInDefer : public FFieldCompiledInInfo
{
	TClassCompiledInDefer(const TCHAR* InName, SIZE_T InClassSize, uint32 InCrc)
	: FFieldCompiledInInfo(InClassSize, InCrc)
	{
		UClassCompiledInDefer(this, InName, InClassSize, InCrc);
	}
	virtual UClass* Register() const override
	{
        LLM_SCOPE(ELLMTag::UObject);
		return TClass::StaticClass();
	}
	virtual const TCHAR* ClassPackage() const override
	{
		return TClass::StaticPackage();
	}
};

void UClassCompiledInDefer(FFieldCompiledInInfo* ClassInfo, const TCHAR* Name, SIZE_T ClassSize, uint32 Crc)
{
	GetDeferredClassRegistration().Add(ClassInfo);
}
static TArray<FFieldCompiledInInfo*>& GetDeferredClassRegistration()
{
	static TArray<FFieldCompiledInInfo*> DeferredClassRegistration;
	return DeferredClassRegistration;
}
```

以及`FCompiledInDefer`的结构:

```c++
struct FCompiledInDefer
{
	FCompiledInDefer(class UClass *(*InRegister)(), class UClass *(*InStaticClass)(), const TCHAR* PackageName, const TCHAR* Name, bool bDynamic, const TCHAR* DynamicPackageName = nullptr, const TCHAR* DynamicPathName = nullptr, void (*InInitSearchableValues)(TMap<FName, FName>&) = nullptr)
	{
		if (bDynamic)
		{
			GetConvertedDynamicPackageNameToTypeName().Add(FName(DynamicPackageName), FName(Name));
		}
		UObjectCompiledInDefer(InRegister, InStaticClass, Name, PackageName, bDynamic, DynamicPathName, InInitSearchableValues);
	}
};

void UObjectCompiledInDefer(UClass *(*InRegister)(), UClass *(*InStaticClass)(), const TCHAR* Name, const TCHAR* PackageName, bool bDynamic, const TCHAR* DynamicPathName, void (*InInitSearchableValues)(TMap<FName, FName>&))
{
	TArray<UClass *(*)()>& DeferredCompiledInRegistration = GetDeferredCompiledInRegistration();
	checkSlow(!DeferredCompiledInRegistration.Contains(InRegister));
	DeferredCompiledInRegistration.Add(InRegister);
}
```

可以看到它们最终都是存储到一个数组里面的，但是数组存储的类型不同，第一个存储的是`TClassCompiledInDefer`类型，第二个存储的是函数指针类型,存储的函数指针是用来构造此类的，可以看到此函数的构造实现如下：

```c++
	UClass* Z_Construct_UClass_AReflectionStudyGameMode()
	{
		static UClass* OuterClass = nullptr;
		if (!OuterClass)
		{
			UE4CodeGen_Private::ConstructUClass(OuterClass, Z_Construct_UClass_AReflectionStudyGameMode_Statics::ClassParams);
		}
		return OuterClass;
	}
```

调用的是`UE4CodeGen_Private`内的构造class的函数，第一个为引用类型，接收一个UClass参数，第二个为构造UClass所需要的参数，

可以看到第一个即`TClassCompiledInDefer`主要是提供了一个Register方法，（到时候由于数组内存储的是这个类，因此可以调用此register函数）,其内部调用了一个`GetPrivateStaticClass()`进而调用`GetPrivateStaticClassBody`而此函数内部进行了UClass对象的构造，是UClass的一些基本信息，如下：

```c++
		ReturnClass = (UClass*)GUObjectAllocator.AllocateUObject(sizeof(UClass), alignof(UClass), true);
		ReturnClass = ::new (ReturnClass)
			UClass
			(
			EC_StaticConstructor,
			Name,
			InSize,
			InAlignment,
			InClassFlags,
			InClassCastFlags,
			InConfigName,
			EObjectFlags(RF_Public | RF_Standalone | RF_Transient | RF_MarkAsNative | RF_MarkAsRootSet),
			InClassConstructor,
			InClassVTableHelperCtorCaller,
			InClassAddReferencedObjects
			);
```

而注意后面那个的参数，是Z_Construct_UClass_AReflectionStudyGameMode函数指针，这个函数针对自己实现的类进行了进一步构造，即注册了自己写的函数和属性方面的信息。

注意此时只是将信息存储到了两个Array内。

此时将信息收集到了全局变量数组内。

## 类型系统注册

`IMPLEMENT_VM_FUNCTION(EX_CallMath, execCallMathFunction);`此宏会被第一个调用。而查看此宏定义，

```c++
#define IMPLEMENT_VM_FUNCTION(BytecodeIndex, func) \
	STORE_INSTRUCTION_NAME(BytecodeIndex) \
	IMPLEMENT_FUNCTION(func) \
	static uint8 UObject##func##BytecodeTemp = GRegisterNative( BytecodeIndex, &UObject::func );

#define IMPLEMENT_FUNCTION(func) \
	static FNativeFunctionRegistrar UObject##func##Registar(UObject::StaticClass(),#func,&UObject::func);

#define STORE_INSTRUCTION_NAME(inst) \
static struct F##inst##Registrar \
{ \
	F##inst##Registrar() \
	{ \
		GNativeFuncNames[inst] = #inst; \
	} \
} inst##RegistrarInst;
```

可以看到此宏会触发`UObject::StaticClass()`函数，从而生成第一个UClass*。`StaticClass`回调用`GetPrivateStaticClass`,而此函数是在IMPLEMENT_CLASS内定义的，UObject的相关IMPLEMENT_CLASS在`NoExportTypes.h`内定义的，此文件内容不参与编译，只是提供给UHT信息。

### GetPrivateStaticClass

```c++
	UClass* TClass::GetPrivateStaticClass() \
	{ \
		static UClass* PrivateStaticClass = NULL; \
		if (!PrivateStaticClass) \
		{ \
			/* this could be handled with templates, but we want it external to avoid code bloat */ \
			GetPrivateStaticClassBody( \
				StaticPackage(), \
				(TCHAR*)TEXT(#TClass) + 1 + ((StaticClassFlags & CLASS_Deprecated) ? 11 : 0), \//类名，加1去掉U、A、F前缀，加11去掉Deprecated_前缀
				PrivateStaticClass, \
				StaticRegisterNatives##TClass, \//注册Native函数的函数指针
				sizeof(TClass), \
				alignof(TClass), \
				(EClassFlags)TClass::StaticClassFlags, \
				TClass::StaticClassCastFlags(), \
				TClass::StaticConfigName(), \//配置文件名
				(UClass::ClassConstructorType)InternalConstructor<TClass>, \//构造函数指针
				(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>, \//hotreload的时候构造虚函数表
				&TClass::AddReferencedObjects, \//添加额外引用对象的函数指针
				&TClass::Super::StaticClass, \//获取基类UClass*的函数指针
				&TClass::WithinClass::StaticClass \//获取对象外部类的函数指针
			); \
		} \
		return PrivateStaticClass; \
	}
```

可以看到此函数只是转调用`GetPrivateStaticClassBody`，这里只看一下输入参数:

1. `StaticPackage`是包名，传入包名是为了构建UClass之后，把UClass\*的对象的OuterPrivate设定为正确的UPackage\*对象。在UE中，UObject必须属于某个UPackage。"/Script/"开头表示这是个代码模块
2. 注意`(UClass::ClassConstructorType)InternalConstructor<TClass>`，`InternalConstructor`是将构造函数包装了一层，因为c++无法获取构造函数的地址。

```c++
template<class T>
void InternalConstructor( const FObjectInitializer& X )
{ 
	T::__DefaultConstructor(X);
}
```

3. Super是类的基类，WithinClass是类的Outer对象。

### GetPrivateStaticClassBody

```c++
void GetPrivateStaticClassBody(
	const TCHAR* PackageName,
	const TCHAR* Name,
	UClass*& ReturnClass,
	void(*RegisterNativeFunc)(),
	uint32 InSize,
	uint32 InAlignment,
	EClassFlags InClassFlags,
	EClassCastFlags InClassCastFlags,
	const TCHAR* InConfigName,
	UClass::ClassConstructorType InClassConstructor,
	UClass::ClassVTableHelperCtorCallerType InClassVTableHelperCtorCaller,
	UClass::ClassAddReferencedObjectsType InClassAddReferencedObjects,
	UClass::StaticClassFunctionType InSuperClassFn,
	UClass::StaticClassFunctionType InWithinClassFn,
	bool bIsDynamic /*= false*/,
	UDynamicClass::DynamicClassInitializerType InDynamicClassInitializerFn /*= nullptr*/
	)
{
//注意，关于hotreaload的此处省略了
	if (!bIsDynamic)
	{
		ReturnClass = (UClass*)GUObjectAllocator.AllocateUObject(sizeof(UClass), alignof(UClass), true);
		ReturnClass = ::new (ReturnClass)
			UClass
			(
			EC_StaticConstructor,
			Name,
			InSize,
			InAlignment,
			InClassFlags,
			InClassCastFlags,
			InConfigName,
			EObjectFlags(RF_Public | RF_Standalone | RF_Transient | RF_MarkAsNative | RF_MarkAsRootSet),
			InClassConstructor,
			InClassVTableHelperCtorCaller,
			InClassAddReferencedObjects
			);
		check(ReturnClass);
	}
	else
	{
		ReturnClass = (UClass*)GUObjectAllocator.AllocateUObject(sizeof(UDynamicClass), alignof(UDynamicClass), GIsInitialLoad);
		ReturnClass = ::new (ReturnClass)
			UDynamicClass
			(
			EC_StaticConstructor,
			Name,
			InSize,
			InAlignment,
			InClassFlags|CLASS_CompiledFromBlueprint,
			InClassCastFlags,
			InConfigName,
			EObjectFlags(RF_Public | RF_Standalone | RF_Transient | RF_Dynamic | (GIsInitialLoad ? RF_MarkAsRootSet : RF_NoFlags)),
			InClassConstructor,
			InClassVTableHelperCtorCaller,
			InClassAddReferencedObjects,
			InDynamicClassInitializerFn
			);
		check(ReturnClass);
	}
	InitializePrivateStaticClass(
		InSuperClassFn(),
		ReturnClass,
		InWithinClassFn(),
		PackageName,
		Name
		);

	// Register the class's native functions.
	RegisterNativeFunc();
}
```

可以清楚的看到这个函数做了四个事：

1. 分配内存，`ReturnClass = (UClass*)GUObjectAllocator.AllocateUObject(sizeof(UClass), alignof(UClass), true);`
2. 在分配好的内存上调用UClass的构造函数。

3. `InitializePrivateStaticClass`，会先加载Super和withinClass

```c++
COREUOBJECT_API void InitializePrivateStaticClass(
	class UClass* TClass_Super_StaticClass,
	class UClass* TClass_PrivateStaticClass,
	class UClass* TClass_WithinClass_StaticClass,
	const TCHAR* PackageName,
	const TCHAR* Name
	)
{
	TRACE_LOADTIME_CLASS_INFO(TClass_PrivateStaticClass, Name);
	NotifyRegistrationEvent(PackageName, Name, ENotifyRegistrationType::NRT_Class, ENotifyRegistrationPhase::NRP_Started);

	/* No recursive ::StaticClass calls allowed. Setup extras. */
	if (TClass_Super_StaticClass != TClass_PrivateStaticClass)
	{
		TClass_PrivateStaticClass->SetSuperStruct(TClass_Super_StaticClass);//设置superclass
	}
	else
	{
		TClass_PrivateStaticClass->SetSuperStruct(NULL);//UObject的superclass为空
	}
	TClass_PrivateStaticClass->ClassWithin = TClass_WithinClass_StaticClass;//设置withinclass

	// Register the class's dependencies, then itself.
	TClass_PrivateStaticClass->RegisterDependencies();
	if (!TClass_PrivateStaticClass->HasAnyFlags(RF_Dynamic))
	{
		// Defer
		TClass_PrivateStaticClass->Register(PackageName, Name);//转到UObjectBase::Register()
	}
	else
	{
		// Register immediately (don't let the function name mistake you!)
		TClass_PrivateStaticClass->DeferredRegister(UDynamicClass::StaticClass(), PackageName, Name);
	}
	NotifyRegistrationEvent(PackageName, Name, ENotifyRegistrationType::NRT_Class, ENotifyRegistrationPhase::NRP_Finished);
}
```

此函数设定了super和withinclass后转到`UObjectBase::Register()`，进行UClass*的注册:

```c++
void UObjectBase::Register(const TCHAR* PackageName,const TCHAR* InName)
{
	TMap<UObjectBase*, FPendingRegistrantInfo>& PendingRegistrants = FPendingRegistrantInfo::GetMap();

	FPendingRegistrant* PendingRegistration = new FPendingRegistrant(this);
	PendingRegistrants.Add(this, FPendingRegistrantInfo(InName, PackageName));
	{
		if (GLastPendingRegistrant)
		{
			GLastPendingRegistrant->NextAutoRegister = PendingRegistration;
		}
		else
		{
			check(!GFirstPendingRegistrant);
			GFirstPendingRegistrant = PendingRegistration;
		}
		GLastPendingRegistrant = PendingRegistration;
	}
}
```

可以看到，用了两种数据结构进行记录，一个Map一个链表，Map保证快速查找的需要，链表为了一些注册顺序方面的需要。注意此处并没有做什么实际的操作，只是将信息记录到了相应结构中。

4. 最后调用RegisterNativeFunc，即之前`GetPrivateStaticClass`用宏拼接传入的函数指针，用来注册native函数，举个例子：

```c++
	void AReflectionStudyGameMode::StaticRegisterNativesAReflectionStudyGameMode()
	{
		UClass* Class = AReflectionStudyGameMode::StaticClass();
		static const FNameNativePtrPair Funcs[] = {
			{ "CallableFuncTest", &AReflectionStudyGameMode::execCallableFuncTest },
			{ "NativeFuncTest", &AReflectionStudyGameMode::execNativeFuncTest },
		};
		FNativeFunctionRegistrar::RegisterFunctions(Class, Funcs, UE_ARRAY_COUNT(Funcs));
	}

void FNativeFunctionRegistrar::RegisterFunctions(class UClass* Class, const FNameNativePtrPair* InArray, int32 NumFunctions)
{
	for (; NumFunctions; ++InArray, --NumFunctions)
	{
		Class->AddNativeFunction(UTF8_TO_TCHAR(InArray->NameUTF8), InArray->Pointer);
	}
}
void UClass::AddNativeFunction(const ANSICHAR* InName, FNativeFuncPtr InPointer)
{
	FName InFName(InName);
	new(NativeFunctionLookupTable) FNativeFunctionLookup(InFName,InPointer);
}
```

而`NativeFunctionLookupTable`是UClass的成员变量`TArray<FNativeFunctionLookup> NativeFunctionLookupTable;`,

```c++
struct FNativeFunctionLookup
{
	FName Name;
	FNativeFuncPtr Pointer;

	FNativeFunctionLookup(FName InName, FNativeFuncPtr InPointer)
		:	Name(InName)
		,	Pointer(InPointer)
	{}
};
```

此结构体就是将函数名和函数指针对应起来。

对于非native的函数，即`BlueprintImplementableEvent`的函数，我们不需要实现函数体，UHT会帮生成一个函数体，当我们在C++里调用ImplementableFunc的时候，其实会触发一次函数查找，如果在蓝图中有定义该名字的函数，则会得到调用。

## 开始main函数

以windows为例：

### WinMain

```c++
int32 WINAPI WinMain( _In_ HINSTANCE hInInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ char*, _In_ int32 nCmdShow )
{
	ErrorLevel = GuardedMain( CmdLine );
	return ErrorLevel;
}
```

循环主题在GuardMain内：

### GuardMain

```c++
/**
 * Static guarded main function. Rolled into own function so we can have error handling for debug/ release builds depending
 * on whether a debugger is attached or not.
 */
int32 GuardedMain( const TCHAR* CmdLine )
{

	BootTimingPoint("DefaultMain");
	// Super early init code. DO NOT MOVE THIS ANYWHERE ELSE!
	FCoreDelegates::GetPreMainInitDelegate().Broadcast();

	// make sure GEngineLoop::Exit() is always called.
	struct EngineLoopCleanupGuard 
	{ 
		~EngineLoopCleanupGuard()
		{
			EngineExit();
		}
	} CleanupGuard;

	int32 ErrorLevel = EnginePreInit( CmdLine );//预初始化


#if WITH_EDITOR
		if (GIsEditor)
		{
			ErrorLevel = EditorInit(GEngineLoop);//编辑器有自己的初始化
		}
		else
#endif
		{
			ErrorLevel = EngineInit();
		}
	}

	while( !IsEngineExitRequested() )
	{
		EngineTick();
	}

	TRACE_BOOKMARK(TEXT("Tick loop end"));

#if WITH_EDITOR
	if( GIsEditor )
	{
		EditorExit();
	}
#endif
	return ErrorLevel;
}
```

主要调用了几个Engine开头的函数和Editor开头的函数，这里主要关注下`EnginePreInit`。

### EnginePreInit

```c++
int32 EnginePreInit( const TCHAR* CmdLine )
{
	int32 ErrorLevel = GEngineLoop.PreInit(CmdLine);

	return(ErrorLevel);
}
```

转调用

### FEngineLoop::PreInit

```c++
int32 FEngineLoop::PreInit(const TCHAR* CmdLine)
{
	const int32 rv1 = PreInitPreStartupScreen(CmdLine);
	if (rv1 != 0)
	{
		PreInitContext.Cleanup();
		return rv1;
	}

	const int32 rv2 = PreInitPostStartupScreen(CmdLine);
	if (rv2 != 0)
	{
		PreInitContext.Cleanup();
		return rv2;
	}

	return 0;
}
```

可以看到主要调用了两个函数`PreInitPreStartupScreen`和`PreInitPostStartScreen`,

### PreInitPreStartupScreen

此函数做了很多事，有一千四百多行，这里主要看下其对CoreUobject的加载阶段

```c++
	{
		SCOPED_BOOT_TIMING("LoadCoreModules");
		if (!LoadCoreModules())
		{
			UE_LOG(LogInit, Error, TEXT("Failed to load Core modules."));
			return 1;
		}
	}
```

### LoadCoreModules

```c++
bool FEngineLoop::LoadCoreModules()
{
	// Always attempt to load CoreUObject. It requires additional pre-init which is called from its module's StartupModule method.
#if WITH_COREUOBJECT
#if USE_PER_MODULE_UOBJECT_BOOTSTRAP // otherwise do it later
	FModuleManager::Get().OnProcessLoadedObjectsCallback().AddStatic(ProcessNewlyLoadedUObjects);
#endif
	return FModuleManager::Get().LoadModule(TEXT("CoreUObject")) != nullptr;
#else
	return true;
#endif
}
```

### LoadModule

```c++
IModuleInterface* FModuleManager::LoadModule( const FName InModuleName )
{
	// We allow an already loaded module to be returned in other threads to simplify
	// parallel processing scenarios but they must have been loaded from the main thread beforehand.
	if(!IsInGameThread())
	{
		return GetModule(InModuleName);
	}

	EModuleLoadResult FailureReason;
	IModuleInterface* Result = LoadModuleWithFailureReason(InModuleName, FailureReason );

	// This should return a valid pointer only if and only if the module is loaded
	checkSlow((Result != nullptr) == IsModuleLoaded(InModuleName));

	return Result;
}
```

继续转向LoadModuleWithFailureReason

### LoadModuleWithFailureReason

```c++
ModuleInfo->Module->StartupModule();
```

其调用了StartupModule,由于是CoreUObject,因此调用`FCoreUObjectModule`重载的这个函数，即

### StartupModule

```c++
	virtual void StartupModule() override
	{
		// Register all classes that have been loaded so far. This is required for CVars to work.		
		UClassRegisterAllCompiledInClasses();
    }
```

而转调用的`UClassRegisterAllCompiledInClasses();`就要注册所有加载的类了。

### UClassRegisterAllCompiledInClasses

```c++
void UClassRegisterAllCompiledInClasses()
{
	SCOPED_BOOT_TIMING("UClassRegisterAllCompiledInClasses");
	TArray<FFieldCompiledInInfo*>& DeferredClassRegistration = GetDeferredClassRegistration();
	for (const FFieldCompiledInInfo* Class : DeferredClassRegistration)
	{
		UClass* RegisteredClass = Class->Register();
	}
	DeferredClassRegistration.Empty();
}
```

注意这里获取的FFieldCompiledInInfo数组即是前面自动注册过程中的一个，这里获取此数组内容，对每个对象调用Register(),此函数只是转调用`StaticClass`函数，而`StaticClass`的一系列流程在类型系统注册中已经讲到，最终在`GetPrivateStaticClassBody`中会调用InitializePrivateStaticClass函数将信息存入一个map和一个链表中,并调用`RegisterNativeFunc();`注册native函数。(具体看`GetPrivateStaticClassBody`函数说明)

## UObject相关

### FEngineLoop::AppInit

```C++
bool FEngineLoop::AppInit()
{
    FCoreDelegates::OnInit.Broadcast(); //在前文注册的委托，在CoreUOject模块加载的时候指向了InitUObject
    return true;
}
```

### InitUObject

```C++
void InitUObject()
{
	FCoreDelegates::OnExit.AddStatic(StaticExit);
#if !USE_PER_MODULE_UOBJECT_BOOTSTRAP // otherwise this is already done
	FModuleManager::Get().OnProcessLoadedObjectsCallback().AddStatic(ProcessNewlyLoadedUObjects);
#endif
	// Object initialization.
	StaticUObjectInit();
}
```

注册了`ProcessNewlyLoadedUObjects`,然后转调用`StaticUObjectInit()`。

### StaticUObjectInit

```c++
void StaticUObjectInit()
{
	UObjectBaseInit();

	// Allocate special packages.
	GObjTransientPkg = NewObject<UPackage>(nullptr, TEXT("/Engine/Transient"), RF_Transient);
	GObjTransientPkg->AddToRoot();

	if( FParse::Param( FCommandLine::Get(), TEXT("VERIFYGC") ) )
	{
		GShouldVerifyGCAssumptions = true;
	}
	if( FParse::Param( FCommandLine::Get(), TEXT("NOVERIFYGC") ) )
	{
		GShouldVerifyGCAssumptions = false;
	}

	UE_LOG(LogInit, Log, TEXT("Object subsystem initialized") );
}
```

继续转调用，但是此转调用之后已经可以NewObject了。

### UObjectBaseInit()

```c++
/**
 * Final phase of UObject initialization. all auto register objects are added to the main data structures.
 */
void UObjectBaseInit()
{
	GUObjectAllocator.AllocatePermanentObjectPool(SizeOfPermanentObjectPool);
	GUObjectArray.AllocateObjectPool(MaxUObjects, MaxObjectsNotConsideredByGC, bPreAllocateUObjectArray);

	void InitAsyncThread();
	InitAsyncThread();

	// Note initialized.
	Internal::GetUObjectSubsystemInitialised() = true;

	UObjectProcessRegistrants();
}
```

做了如下几件事:初始化UObject的内存分配系统；创建异步加载线程，用来后续Package的加载；指定已经初始化完成；处理注册项。

### UObjectProcessRegistrants()

```c++
/**
 * Process the auto register objects adding them to the UObject array
 */
static void UObjectProcessRegistrants()
{
	SCOPED_BOOT_TIMING("UObjectProcessRegistrants");

	check(UObjectInitialized());
	// Make list of all objects to be registered.
	TArray<FPendingRegistrant> PendingRegistrants;
	DequeuePendingAutoRegistrants(PendingRegistrants);

	for(int32 RegistrantIndex = 0;RegistrantIndex < PendingRegistrants.Num();++RegistrantIndex)
	{
		const FPendingRegistrant& PendingRegistrant = PendingRegistrants[RegistrantIndex];

		UObjectForceRegistration(PendingRegistrant.Object, false);

		check(PendingRegistrant.Object->GetClass()); // should have been set by DeferredRegister

		// Register may have resulted in new pending registrants being enqueued, so dequeue those.
		DequeuePendingAutoRegistrants(PendingRegistrants);
	}
}

static void DequeuePendingAutoRegistrants(TArray<FPendingRegistrant>& OutPendingRegistrants)
{
	// We process registrations in the order they were enqueued, since each registrant ensures
	// its dependencies are enqueued before it enqueues itself.
	FPendingRegistrant* NextPendingRegistrant = GFirstPendingRegistrant;
	GFirstPendingRegistrant = NULL;
	GLastPendingRegistrant = NULL;
	while(NextPendingRegistrant)
	{
		FPendingRegistrant* PendingRegistrant = NextPendingRegistrant;
		OutPendingRegistrants.Add(*PendingRegistrant);
		NextPendingRegistrant = PendingRegistrant->NextAutoRegister;
		delete PendingRegistrant;
	};
}

void UObjectForceRegistration(UObjectBase* Object, bool bCheckForModuleRelease)
{
	TMap<UObjectBase*, FPendingRegistrantInfo>& PendingRegistrants = FPendingRegistrantInfo::GetMap();

	FPendingRegistrantInfo* Info = PendingRegistrants.Find(Object);
	if (Info)
	{
		const TCHAR* PackageName = Info->PackageName;
#if USE_PER_MODULE_UOBJECT_BOOTSTRAP
		if (bCheckForModuleRelease)
		{
			UObjectReleaseModuleRegistrants(FName(PackageName));
		}
#endif
		const TCHAR* Name = Info->Name;
		PendingRegistrants.Remove(Object);  // delete this first so that it doesn't try to do it twice
		Object->DeferredRegister(UClass::StaticClass(),PackageName,Name);
	}
}
```

此函数的主要做的事是从`GFirstPendingRegistrant`的链表中抽出为FPendingRegistrant数组，并对每个数组对象进行`UObjectForceRegistration`来注册。注意对每一个对象进行注册时，都要重新从链表中获取，因为注册时可能需要其他对象的加载，这样就有新的注册项进来。

### UObjectBase::DeferredRegister

```c++
/**
 * Convert a boot-strap registered class into a real one, add to uobject array, etc
 *
 * @param UClassStaticClass Now that it is known, fill in UClass::StaticClass() as the class
 */
void UObjectBase::DeferredRegister(UClass *UClassStaticClass,const TCHAR* PackageName,const TCHAR* InName)
{
	check(UObjectInitialized());
	// Set object properties.
	UPackage* Package = CreatePackage(nullptr, PackageName);
	check(Package);
	Package->SetPackageFlags(PKG_CompiledIn);
	OuterPrivate = Package;

	check(UClassStaticClass);
	check(!ClassPrivate);
	ClassPrivate = UClassStaticClass;

	// Add to the global object table.
	AddObject(FName(InName), EInternalObjectFlags::None);

	// Make sure that objects disregarded for GC are part of root set.
	check(!GUObjectArray.IsDisregardForGC(this) || GUObjectArray.IndexToObject(InternalIndex)->IsRootSet());

	UE_LOG(LogUObjectBootstrap, Verbose, TEXT("UObjectBase::DeferredRegister %s %s"), PackageName, InName);
}
```

对象真正注册的地方，设定Package和OuterPrivate以及NamePrivate,这一步让一个个对象有了名字。注意此时仍没有`UProperty`和`UFunction`。此时完成了一个个对象之间的联系。

1. **NamePrivate**：定义了对象的名字
2. **OuterPrivate**：定义了对象的从属关系
3. **ClassPrivate**：定义了对象的类型关系
4. **SuperStruct**：定义了类型的继承关系

### ProcessNewlyLoadedUObjects()

在`FEngineLoop::PreInitPostStartupScreen`中，此函数被调用，同时由于其加入了回调，因此在`LoadModuleWithFailureReason`(前面有)中也触发了（如果已经添加进去）`ProcessLoadedObjectsCallback.Broadcast(InModuleName, bCanProcessNewlyLoadedObjects);`

```c++
void ProcessNewlyLoadedUObjects(FName Package, bool bCanProcessNewlyLoadedObjects)
{
	const TArray<UClass* (*)()>& DeferredCompiledInRegistration = GetDeferredCompiledInRegistration();
	const TArray<FPendingStructRegistrant>& DeferredCompiledInStructRegistration = GetDeferredCompiledInStructRegistration();
	const TArray<FPendingEnumRegistrant>& DeferredCompiledInEnumRegistration = GetDeferredCompiledInEnumRegistration();

	bool bNewUObjects = false;
	while (GFirstPendingRegistrant || DeferredCompiledInRegistration.Num() || DeferredCompiledInStructRegistration.Num() || DeferredCompiledInEnumRegistration.Num())
	{
		bNewUObjects = true;
		UObjectProcessRegistrants();
		UObjectLoadAllCompiledInStructs();
		UObjectLoadAllCompiledInDefaultProperties();
	}

	if (bNewUObjects && !GIsInitialLoad)
	{
		UClass::AssembleReferenceTokenStreams();
	}
}
```

可以看到，这里对之前注册到全局对象中的数据进行处理，

```c++
/**
 * Process the auto register objects adding them to the UObject array
 */
static void UObjectProcessRegistrants()
{
	SCOPED_BOOT_TIMING("UObjectProcessRegistrants");

	check(UObjectInitialized());
	// Make list of all objects to be registered.
	TArray<FPendingRegistrant> PendingRegistrants;
	DequeuePendingAutoRegistrants(PendingRegistrants);

	for(int32 RegistrantIndex = 0;RegistrantIndex < PendingRegistrants.Num();++RegistrantIndex)
	{
		const FPendingRegistrant& PendingRegistrant = PendingRegistrants[RegistrantIndex];

		UObjectForceRegistration(PendingRegistrant.Object, false);

		check(PendingRegistrant.Object->GetClass()); // should have been set by DeferredRegister

		// Register may have resulted in new pending registrants being enqueued, so dequeue those.
		DequeuePendingAutoRegistrants(PendingRegistrants);
	}
}
/**
 * Call StaticStruct for each struct...this sets up the internal singleton, and important works correctly with hot reload
 */
static void UObjectLoadAllCompiledInStructs()
{
	SCOPED_BOOT_TIMING("UObjectLoadAllCompiledInStructs");

	TArray<FPendingEnumRegistrant> PendingEnumRegistrants = MoveTemp(GetDeferredCompiledInEnumRegistration());
	TArray<FPendingStructRegistrant> PendingStructRegistrants = MoveTemp(GetDeferredCompiledInStructRegistration());

	{
		SCOPED_BOOT_TIMING("UObjectLoadAllCompiledInStructs -  CreatePackages (could be optimized!)");
		// Load Enums first
		for (const FPendingEnumRegistrant& EnumRegistrant : PendingEnumRegistrants)
		{
			// Make sure the package exists in case it does not contain any UObjects
			CreatePackage(nullptr, EnumRegistrant.PackageName);
		}
		for (const FPendingStructRegistrant& StructRegistrant : PendingStructRegistrants)
		{
			// Make sure the package exists in case it does not contain any UObjects or UEnums
			CreatePackage(nullptr, StructRegistrant.PackageName);
		}
	}

	// Load Structs

	for (const FPendingEnumRegistrant& EnumRegistrant : PendingEnumRegistrants)
	{
		EnumRegistrant.RegisterFn();
	}

	for (const FPendingStructRegistrant& StructRegistrant : PendingStructRegistrants)
	{
		StructRegistrant.RegisterFn();
	}
}
/**
 * Load any outstanding compiled in default properties
 */
static void UObjectLoadAllCompiledInDefaultProperties()
{
	TRACE_LOADTIME_REQUEST_GROUP_SCOPE(TEXT("UObjectLoadAllCompiledInDefaultProperties"));

	static FName LongEnginePackageName(TEXT("/Script/Engine"));

	TArray<UClass *(*)()>& DeferredCompiledInRegistration = GetDeferredCompiledInRegistration();

	const bool bHaveRegistrants = DeferredCompiledInRegistration.Num() != 0;
	if( bHaveRegistrants )
	{
		SCOPED_BOOT_TIMING("UObjectLoadAllCompiledInDefaultProperties");
		TArray<UClass*> NewClasses;
		TArray<UClass*> NewClassesInCoreUObject;
		TArray<UClass*> NewClassesInEngine;
		TArray<UClass* (*)()> PendingRegistrants = MoveTemp(DeferredCompiledInRegistration);
		for (UClass* (*Registrant)() : PendingRegistrants)
		{
			UClass* Class = Registrant();
			UE_LOG(LogUObjectBootstrap, Verbose, TEXT("UObjectLoadAllCompiledInDefaultProperties After Registrant %s %s"), *Class->GetOutermost()->GetName(), *Class->GetName());
			if (Class->GetOutermost()->GetFName() == GLongCoreUObjectPackageName)
			{
				NewClassesInCoreUObject.Add(Class);
			}
			else if (Class->GetOutermost()->GetFName() == LongEnginePackageName)
			{
				NewClassesInEngine.Add(Class);
			}
			else
			{
				NewClasses.Add(Class);
			}
		}
    }
}
```

可以看到循环主体的三个函数做的事，UObjectProcessRegistrants已经说过了，为生成的UClass*对象注册，生成其Package，Enum和Struct都是在`UObjectLoadAllCompiledInStructs()`中进行注册的，而具体类的信息的注册在`UObjectLoadAllCompiledInDefaultProperties()`中，是当初收集到的static FCompiledInDefer对象。

# 反射应用

## 获取某种类型的对象

```c++
TArray<UObject*> result;
GetObjectsOfClass(UClass::StaticClass(), result);   //获取所有的class和interface
GetObjectsOfClass(UEnum::StaticClass(), result);   //获取所有的enum
GetObjectsOfClass(UScriptStruct::StaticClass(), result);   //获取所有的struct
```

`GetObjectsOfClass`,获取某个class下面的所有对象。

## 根据名字获取不同类型对象。

`UClass* classObj=FindObject<UClass>(ANY_PACKAGE,"MyClass"); `

## 遍历对象内部字段

```c++
const UStruct* structClass; //任何复合类型都可以
//遍历属性
for (TFieldIterator<UProperty> i(structClass); i; ++i)
{
    UProperty* prop=*i; 
}
//遍历函数
for (TFieldIterator<UFunction> i(structClass); i; ++i)
{
    UFunction* func=*i; 
    //遍历函数的参数
    for (TFieldIterator<UProperty> i(func); i; ++i)
    {
        UProperty* param=*i; 
        if( param->PropertyFlags & CPF_ReturnParm ) //这是返回值
        {

        }
    }
}
//遍历接口
const UClass* classObj; //只有UClass才有接口
for (const FImplementedInterface& ii : classObj->Interfaces)
{
    UClass* interfaceClass = ii.Class;
}
//遍历枚举
const UEnum* enumClass;
for (int i = 0; i < enumClass->NumEnums(); ++i)
{
    FName name = enumClass->GetNameByIndex(i);
    int value = enumClass->GetValueByIndex(i);
}
//遍历元数据
#if WITH_METADATA
const UObject* obj;//可以是任何对象，但一般是UField才有值
UMetaData* metaData = obj->GetOutermost()->GetMetaData();
TMap<FName, FString>* keyValues = metaData->GetMapForObject(obj);
if (keyValues != nullptr&&keyValues->Num() > 0)
{
    for (const auto& i : *keyValues)
    {
        FName key=i.Key;
        FString value=i.Value;
    }
}
#endif
```

## 查找属性和函数

```c++
//查找属性
UProperty* UStruct::FindPropertyByName(FName InName) const
{
    for (UProperty* Property = PropertyLink; Property != NULL; Property = Property->PropertyLinkNext)
    {
        if (Property->GetFName() == InName)
        {
            return Property;
        }
    }
    return NULL;
}

//查找函数
UFunction* UClass::FindFunctionByName(FName InName, EIncludeSuperFlag::Type IncludeSuper) const;
```

## 查看继承

```c++
const UStruct* structClass; //结构和类
TArray<FString> classNames;
classNames.Add(structClass->GetName());
UStruct* superClass = structClass->GetSuperStruct();
while (superClass)
{
    classNames.Add(superClass->GetName());
    superClass = superClass->GetSuperStruct();
}
FString str= FString::Join(classNames, TEXT("->")); //会输出MyClass->UObject
```

## 获取所有子类

```c++
const UClass* classObj; //结构和类
TArray<UClass*> result;
GetDerivedClasses(classObj, result, false);
//函数原型是
void GetDerivedClasses(UClass* ClassToLookFor, TArray<UClass *>& Results, bool bRecursive);
```

## 获取实现了某个接口的所有子类

```c++
TArray<UObject*> result;
GetObjectsOfClass(UClass::StaticClass(), result);

TArray<UClass*> classes;
for (UObject* obj : result)
{
    UClass* classObj = Cast<UClass>(obj);
    if (classObj->ImplementsInterface(interfaceClass))//判断实现了某个接口
    {
        classes.Add(classObj);
    }
}
```

## 获取属性值

```c++
template<typename ValueType>
ValueType* UProperty::ContainerPtrToValuePtr(void* ContainerPtr, int32 ArrayIndex = 0) const
{
    return (ValueType*)ContainerVoidPtrToValuePtrInternal(ContainerPtr, ArrayIndex);
}
template<typename ValueType>
ValueType* UProperty::ContainerPtrToValuePtr(UObject* ContainerPtr, int32 ArrayIndex = 0) const
{
    return (ValueType*)ContainerVoidPtrToValuePtrInternal(ContainerPtr, ArrayIndex);
}

void* UProperty::ContainerVoidPtrToValuePtrInternal(void* ContainerPtr, int32 ArrayIndex) const
{
    //check...
    return (uint8*)ContainerPtr + Offset_Internal + ElementSize * ArrayIndex;
}
void* UProperty::ContainerUObjectPtrToValuePtrInternal(UObject* ContainerPtr, int32 ArrayIndex) const
{
    //check...
    return (uint8*)ContainerPtr + Offset_Internal + ElementSize * ArrayIndex;
}
//获取对象或结构里的属性值地址，需要自己转换成具体类型
void* propertyValuePtr = property->ContainerPtrToValuePtr<void*>(object);
//包含对象引用的属性可以获得对象
UObject* subObject = objectProperty->GetObjectPropertyValue_InContainer(object);
```

由于获取到的是指针地址，因此可以直接设置属性了。

```c++
	virtual const TCHAR* ImportText_Internal( const TCHAR* Buffer, void* Data, int32 PortFlags, UObject* Parent, FOutputDevice* ErrorText ) const override;

	virtual void ExportTextItem( FString& ValueStr, const void* PropertyValue, const void* DefaultValue, UObject* Parent, int32 PortFlags, UObject* ExportRootScope ) const override;
```

通过字符串导入和导出。

## 调用函数

```c++
//方法原型
int32 UMyClass::Func(float param1); 

UFUNCTION(BlueprintCallable)
int32 InvokeFunction(UObject* obj, FName functionName,float param1)
{
    struct MyClass_Func_Parms   //定义一个结构用来包装参数和返回值，就像在gen.cpp里那样
    {
        float param1;
        int32 ReturnValue;
    };
    UFunction* func = obj->FindFunctionChecked(functionName);
    MyClass_Func_Parms params;
    params.param1=param1;
    obj->ProcessEvent(func, &params);
    return params.ReturnValue;
}
//使用
int r=InvokeFunction(obj,"Func",123.f);
```

ProcessEvent也是UE4里事先定义好的非常方便的函数，内部会自动的处理蓝图VM的问题。当然，更底层的方法也可以是：

```cpp
//调用1
obj->ProcessEvent(func, &params);
//调用2
FFrame frame(nullptr, func, &params, nullptr, func->Children);
obj->CallFunction(frame, &params + func->ReturnValueOffset, func);
//调用3
FFrame frame(nullptr, func, &params, nullptr, func->Children);
func->Invoke(obj, frame, &params + func->ReturnValueOffset);
```

调用123其实是差不多等价的，在没有obj的情况下调用static函数，可以用调用3的方式。我们知道写在蓝图里的函数和事件最终也都是会编译生成的UFunction对象的，所以用此方法可以直接调用蓝图里的成员函数和自定义事件。

# 参考

[UE4反射机制](https://zhuanlan.zhihu.com/p/60622181)

[反射](https://www.cnblogs.com/ghl_carmack/p/5677090.html)

[InsideUE4](https://zhuanlan.zhihu.com/insideue4)